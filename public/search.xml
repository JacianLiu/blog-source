<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL的锁</title>
      <link href="/2021/06/28/ef14e1b75d72/"/>
      <url>/2021/06/28/ef14e1b75d72/</url>
      
        <content type="html"><![CDATA[<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><blockquote><p>当多个事务或进程访问同一个资源时，为了保证数据的一致性就会用到锁机制，在MySQL中锁有多种不同的分类。</p></blockquote><h3 id="以操作粒度区分"><a href="#以操作粒度区分" class="headerlink" title="以操作粒度区分"></a>以操作粒度区分</h3><blockquote><p>行级锁、表级锁和页级锁</p></blockquote><ul><li>表级锁：每次操作锁住整张表。锁定的粒度大、开销小、加锁快；不会发生死锁，但发生锁冲突的概率极高，并发度最低，应用在InnoDB、MyISAM、BDB中；</li><li>行级锁：每次操作锁住一行数据。锁定的粒度小、开销大、加锁慢；会出现死锁，发生锁冲突的概率极低，并发度最高，应用在InnoDB中；</li><li>页级锁：每次锁定相邻的一组记录。锁定粒度、开销、加锁时间介于行级锁和表级锁之间；会出现死锁，并发度一般，应用在BDB中；</li></ul><table><thead><tr><th></th><th>行锁</th><th>表锁</th><th>页锁</th></tr></thead><tbody><tr><td>MyISAM</td><td></td><td>√</td><td></td></tr><tr><td>BDB</td><td></td><td>√</td><td>√</td></tr><tr><td>MyISAM</td><td>√</td><td>√</td><td></td></tr></tbody></table><h3 id="以操作类型区分"><a href="#以操作类型区分" class="headerlink" title="以操作类型区分"></a>以操作类型区分</h3><blockquote><p>读锁、写锁</p></blockquote><ul><li>读锁（S）：共享锁，针对同一份数据，多个读操作可以同时进行不会互相影响；</li><li>写锁（X）：排它锁，当前写操作没有完成时，会阻塞其他读和写操作；</li></ul><blockquote><p>为了允许行锁和表锁的共存，实现多粒度的锁机制，InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁：</p></blockquote><ul><li>意向读锁（IS）、意向写锁（IX）：属于表级锁，S和X主要针对行级锁。在对表记录添加S或X锁之前，会先对表添加IS和IX锁，表明某个事务正在持有某些行的锁、或该事务准备去持有锁；意向锁存在是为了协调锁之间的关系，支持多粒度锁共存；</li></ul><blockquote><p>为什么意向锁是表级锁？</p><p>为了减少确认次数，提升性能：如果意向锁是行锁，需要遍历每一行去确认数据是否已经加锁；如果是表锁的话，只需要判断一次就知道有没有数据行被锁定；</p><p>意向锁是如何支持行级锁、表级锁共存的？</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li>S锁：事务A对记录添加了S锁，可以对记录进行读取操作，不能做修改，其它事务可以对改记录追加S锁，但是不能追加X锁，追加X锁需要等记录的S锁全部释放；</li><li>X锁：事务A对记录添加了X锁，可以对记录进行读和修改操作，其它事务不能对该记录做读和修改操作。</li></ul><h4 id="意向锁、共享锁和排它锁之间的兼容关系"><a href="#意向锁、共享锁和排它锁之间的兼容关系" class="headerlink" title="意向锁、共享锁和排它锁之间的兼容关系"></a>意向锁、共享锁和排它锁之间的兼容关系</h4><table><thead><tr><th></th><th>事务A持有：X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>事务B获取：X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><ul><li>意向锁相互兼容，因为IX和IS只是表明申请更低层次的级别元素的X、S操作；</li><li>表级S和X、IX不兼容，因为上了表级S锁后，不允许其它事务再加X锁；</li><li>上了表级X锁后，会修改数据，所以表级X锁和 IS、IX、S、X（即使是行排他锁，因为表级锁定的行肯定包括行级锁定的行，所以表级X和IX、行级X）不兼容。</li></ul><h3 id="以操作性能区分"><a href="#以操作性能区分" class="headerlink" title="以操作性能区分"></a>以操作性能区分</h3><blockquote><p>乐观锁、悲观锁</p></blockquote><ul><li>乐观锁：一般采用的方式是对数据记录版本进行对比，在数据更新提交时才会进行冲突检测，如果发现冲突了，则提示错误信息；</li><li>悲观锁：在对一条记录进行修改时，为了避免被其他人修改，在修改数据之前先锁定再修改的方式。共享锁和排它锁是悲观锁的不同实现。</li></ul><h2 id="InnoDB的行锁"><a href="#InnoDB的行锁" class="headerlink" title="InnoDB的行锁"></a>InnoDB的行锁</h2><h3 id="行锁的实现原理"><a href="#行锁的实现原理" class="headerlink" title="行锁的实现原理"></a>行锁的实现原理</h3><p>意向锁是InnoDB自动加的，不需要用户干预；对于  <code>UPDATE</code> 、<code>DELETE</code> 和 <code>INSERT</code>  语句，InnoDB会自动给涉及的数据集增加排他锁（X）；对于普通的 <code>SELECT</code> 语句，InnoDB不会加任何锁；事务也可以通过以下语句显式的给记录集加共享锁 <code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code> 和排它锁 <code>SELECT * FROM table_name WHERE ... FOR UPDATE</code> 。</p><p>在InnoDB中，支持行锁和表锁，行锁又分为共享锁和排它锁。InnoDB行锁是通过对索引数据页上的记录加锁实现的。由于InnoDB行锁的实现特点，<strong>导致只有通过索引条件检索并且执行计划中真正使用到索引时InnoDB才会使用行锁</strong> ；并且不论使用主键索引、唯一索引、普通索引，InnoDB都会使用行锁来进行加锁，否则InnoDB将使用表锁。由于InnoDB是针对索引加锁，而不是针对记录加锁，所以即使多个事务访问不同行的记录，但如果使用的是相同的索引，还是会出现锁冲突的情况，甚至出现死锁。</p><h3 id="行锁的不同实现"><a href="#行锁的不同实现" class="headerlink" title="行锁的不同实现"></a>行锁的不同实现</h3><p>行锁的主要实现有三种： <code>Record Lock</code> 、 <code>Gap Lock</code> 和 <code>Next-Key Lock</code> 。</p><ul><li>RecordLock：记录锁，锁定单个行记录的锁，RC和RR隔离级别支持。</li><li>GapLock：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。范围锁，RR隔离级别支持。（加锁之后间隙范围内不允许插入数据，防止发生幻读）<ul><li>Insert Intention：插入意向锁，插入意向锁中虽然含有意向锁三个字，但是它不属于意向锁，而是属于间隙锁，在insert时产生；意向锁是表锁，而插入意向锁是行锁。</li></ul></li><li>Next-Key Lock：临键锁，它是记录锁和间隙锁的结合体，锁住数据的同时锁住数据前后范围。记录锁+范围缩，RR隔离级别支持。</li></ul><blockquote><p><strong>insert 的加锁流程：</strong></p><p>执行 <code>insert</code> 之后，如果没有任何冲突，在 <code>show engine innodb status</code> 命令中是看不到任何锁的，<strong>这是因为 <code>insert</code> 加的是隐式锁。什么是隐式锁？隐式锁的意思就是没有锁！</strong></p><p>所以，根本就不存在先加插入意向锁，再加排他记录锁的说法，在执行 <code>insert</code> 语句时，什么锁都不会加。当其他事务执行 <code>select ... lock in share mode</code> 时触发了隐式锁的转换。</p><p>InnoDb 在插入记录时，是不加锁的。如果事务 A 插入记录且未提交，这时事务 B 尝试对这条记录加锁：事务 B 会先去判断记录上保存的事务 id 是否活跃，如果活跃的话，那么就帮助事务 A 去建立一个锁对象（排他记录锁），然后自身进入等待事务 A 状态，这就是所谓的隐式锁转换为显式锁。</p><p><strong>结论：</strong></p><ol><li>执行 <code>insert</code> 语句，判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁；</li><li>执行 <code>select ... lock in share mode</code> 语句，判断记录上是否存在活跃的事务，如果存在，则为 <code>insert</code> 事务创建一个排他记录锁，并将自己加入到锁等待队列；</li></ol></blockquote><h3 id="MySQL使用间隙锁的目的"><a href="#MySQL使用间隙锁的目的" class="headerlink" title="MySQL使用间隙锁的目的"></a>MySQL使用间隙锁的目的</h3><p>间隙锁的主要目的是为了防止幻读，其主要通过两个方面实现这个目的：</p><ol><li>防止间隙内有新数据被插入</li><li>防止已存在的数据，更新成间隙内的数据</li></ol><p>另外一方面，是为了满足其恢复和复制的需要。对于基于语句的日志格式的恢复和复制而言，由于MySQL的BINLONG是按照事务提交的先后顺序记录的，因此要正确恢复或者复制数据，就必须满足：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，根本原因还是不允许出现幻读。</p><h3 id="锁规则"><a href="#锁规则" class="headerlink" title="锁规则"></a>锁规则</h3><ol><li>规则1：加锁的基本单位是临键锁（Next-key Lock）</li><li>规则2：查找过程中访问的对象才会加锁</li><li>优化1：索引上的<strong>等值查询</strong>，给唯一键加索引的时候，如果查询值存在，临键锁（Next-key Lock）会退化成记录锁（Record Lock）；如果查询值不存在，会按照优化2进行优化</li><li>优化2：索引上的<strong>等值查询</strong>，向右遍历时且最近一个值不满足等值条件时，临键锁（Next-key Lock）会退化成间隙锁（Gap Lock）</li><li>bug1：<strong>唯一索引上</strong>的<strong>范围查询</strong>会访问到不满足条件的第一个值为止。</li></ol><blockquote><p>在mysql8.0.18及以上已经没有这个bug</p></blockquote><h3 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h3><p>对不同记录加锁时，如果符合下边这些条件：</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p>那么这些记录的锁就可以被放到一个<code>锁结构</code>中。</p><h3 id="锁的兼容性"><a href="#锁的兼容性" class="headerlink" title="锁的兼容性"></a>锁的兼容性</h3><table><thead><tr><th></th><th>事务A持有：Gap</th><th>Insert Intention</th><th>Record</th><th>Next-Key</th></tr></thead><tbody><tr><td>事务B获取：Gap</td><td>兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>Insert Intention</td><td>冲突</td><td>兼容</td><td>兼容</td><td>冲突</td></tr><tr><td>Record</td><td>兼容</td><td>兼容</td><td>冲突</td><td>冲突</td></tr><tr><td>Next-Key</td><td>兼容</td><td>兼容</td><td>冲突</td><td>冲突</td></tr></tbody></table><blockquote><p>从图中可以看出，横向为事务A拥有的锁，竖向为事务B想要获取的锁；举例： 如果前一个事务A <strong>持有 gap 锁 或者 next-key 锁的时候，后一个事务B如果想要持有 Insert Intention 锁的时候会不兼容，出现锁等待</strong>。</p></blockquote><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><ol><li><code>SELECT ... FROM ...</code> ：InnoDB采用MVCC机制实现非阻塞读，对于普通的 SELECT 语句，InnoDB不加锁。</li><li><code>SELECT ... FROM ... LOCK In SHARE MODE</code> ：显式追加共享锁，InnoDB会使用临键锁（Next-key Lock）进行处理，如果发现了唯一索引，可以降级为记录锁（RecordLock）。</li><li><code>SELECT ... FROM ... FOR UPDATE</code> ：显式追加排它锁，InnoDB会使用Next-Key Lock锁进行处理，如果发现唯一索引，可以降级为RecordLock锁。</li><li><code>UPDATE ... WHERE</code> ：InnoDB会使用临键锁（Next-key Lock）进行处理，如果扫描发现唯一索引，可以降级为记录锁（RecordLock）。</li><li><code>DELETE ... WHERE</code>：InnoDB会使用临键锁（Next-key Lock）进行处理，如果扫描发现唯一索引，可以降级为记录锁（RecordLock）。</li><li><code>insert</code>：InnoDB会在将要插入的那一行设置一个排他的记录锁（RecordLock）。</li></ol><p>以 <code>update t1 set name=‘XX’ where id=10</code> 操作为例：</p><h4 id="主键加锁"><a href="#主键加锁" class="headerlink" title="主键加锁"></a>主键加锁</h4><p><img src="https://img.jacian.com/note/img/20210531223413.png" alt="主键加锁"></p><p>加锁行为：仅在id=10的主键索引记录上加X锁。</p><h4 id="唯一键加锁"><a href="#唯一键加锁" class="headerlink" title="唯一键加锁"></a>唯一键加锁</h4><p><img src="https://img.jacian.com/note/img/20210531223428.png" alt="唯一键加锁"></p><p>加锁行为：先在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。</p><h4 id="非唯一键加锁"><a href="#非唯一键加锁" class="headerlink" title="非唯一键加锁"></a>非唯一键加锁</h4><p><img src="https://img.jacian.com/note/img/20210531223444.png" alt="非唯一键加锁"></p><p>加锁行为：对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)(11,f)范围分别加Gap Lock。</p><h4 id="无索引加锁"><a href="#无索引加锁" class="headerlink" title="无索引加锁"></a>无索引加锁</h4><p><img src="https://img.jacian.com/note/img/20210531223503.png" alt="无索引加锁"></p><p>加锁行为：表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎 锁机制是基于索引实现的记录锁定）。</p><h2 id="锁模拟"><a href="#锁模拟" class="headerlink" title="锁模拟"></a>锁模拟</h2><p>查看事务、锁的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当前运行的所有事务</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"><span class="comment">-- 当前出现的锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line"><span class="comment">-- 锁等待的对应关系</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure><p>输出结果解析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当前运行的所有事务 INFORMATION_SCHEMA.INNODB_TRX 表信息</span></span><br><span class="line">root<span class="variable">@127</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> : information_schema <span class="number">13</span>:<span class="number">29</span>:<span class="number">05</span><span class="operator">&gt;</span> <span class="keyword">desc</span> innodb_trx ;</span><br><span class="line"><span class="operator">+</span>—————————<span class="operator">-</span><span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span>—————————<span class="operator">-</span><span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> trx_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">18</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#事务ID</span><br><span class="line"><span class="operator">|</span> trx_state <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">13</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#事务状态：</span><br><span class="line"><span class="operator">|</span> trx_started <span class="operator">|</span> datetime <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0000</span><span class="number">-00</span><span class="number">-00</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span> <span class="operator">|</span>#事务开始时间；</span><br><span class="line"><span class="operator">|</span> trx_requested_lock_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">81</span>) <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#innodb_locks.lock_id</span><br><span class="line"><span class="operator">|</span> trx_wait_started <span class="operator">|</span> datetime <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#事务开始等待的时间</span><br><span class="line"><span class="operator">|</span> trx_weight <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#</span><br><span class="line"><span class="operator">|</span> trx_mysql_thread_id <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#事务线程ID</span><br><span class="line"><span class="operator">|</span> trx_query <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">1024</span>) <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#具体<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="operator">|</span> trx_operation_state <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">64</span>) <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#事务当前操作状态</span><br><span class="line"><span class="operator">|</span> trx_tables_in_use <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#事务中有多少个表被使用</span><br><span class="line"><span class="operator">|</span> trx_tables_locked <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#事务拥有多少个锁</span><br><span class="line"><span class="operator">|</span> trx_lock_structs <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#</span><br><span class="line"><span class="operator">|</span> trx_lock_memory_bytes <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#事务锁住的内存大小（B）</span><br><span class="line"><span class="operator">|</span> trx_rows_locked <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#事务锁住的行数</span><br><span class="line"><span class="operator">|</span> trx_rows_modified <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#事务更改的行数</span><br><span class="line"><span class="operator">|</span> trx_concurrency_tickets <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#事务并发票数</span><br><span class="line"><span class="operator">|</span> trx_isolation_level <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">16</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#事务隔离级别</span><br><span class="line"><span class="operator">|</span> trx_unique_checks <span class="operator">|</span> <span class="type">int</span>(<span class="number">1</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#是否唯一性检查</span><br><span class="line"><span class="operator">|</span> trx_foreign_key_checks <span class="operator">|</span> <span class="type">int</span>(<span class="number">1</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#是否外键检查</span><br><span class="line"><span class="operator">|</span> trx_last_foreign_key_error <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">256</span>) <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#最后的外键错误</span><br><span class="line"><span class="operator">|</span> trx_adaptive_hash_latched <span class="operator">|</span> <span class="type">int</span>(<span class="number">1</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#</span><br><span class="line"><span class="operator">|</span> trx_adaptive_hash_timeout <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> <span class="operator">|</span>#</span><br><span class="line"><span class="operator">+</span>—————————<span class="operator">-</span><span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前出现的锁 INFORMATION_SCHEMA.INNODB_LOCKS 信息</span></span><br><span class="line">root<span class="variable">@127</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> : information_schema <span class="number">13</span>:<span class="number">28</span>:<span class="number">38</span><span class="operator">&gt;</span> <span class="keyword">desc</span> innodb_locks;</span><br><span class="line"><span class="operator">+</span>————<span class="operator">-</span><span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span>————<span class="operator">-</span><span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> lock_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">81</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#锁ID</span><br><span class="line"><span class="operator">|</span> lock_trx_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">18</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#拥有锁的事务ID</span><br><span class="line"><span class="operator">|</span> lock_mode <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#锁模式</span><br><span class="line"><span class="operator">|</span> lock_type <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#锁类型</span><br><span class="line"><span class="operator">|</span> lock_table <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">1024</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#被锁的表</span><br><span class="line"><span class="operator">|</span> lock_index <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">1024</span>) <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#被锁的索引</span><br><span class="line"><span class="operator">|</span> lock_space <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#被锁的表空间号</span><br><span class="line"><span class="operator">|</span> lock_page <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#被锁的页号</span><br><span class="line"><span class="operator">|</span> lock_rec <span class="operator">|</span> <span class="type">bigint</span>(<span class="number">21</span>) unsigned <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#被锁的记录号</span><br><span class="line"><span class="operator">|</span> lock_data <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">8192</span>) <span class="operator">|</span> YES <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span>#被锁的数据</span><br><span class="line"><span class="operator">+</span>————<span class="operator">-</span><span class="operator">+</span>———————<span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--  锁等待的对应关系 INFORMATION_SCHEMA.INNODB_LOCK_WAITS 信息</span></span><br><span class="line">root<span class="variable">@127</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> : information_schema <span class="number">13</span>:<span class="number">28</span>:<span class="number">56</span><span class="operator">&gt;</span> <span class="keyword">desc</span> innodb_lock_waits;</span><br><span class="line"><span class="operator">+</span>——————<span class="operator">-</span><span class="operator">+</span>————<span class="operator">-</span><span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span>——————<span class="operator">-</span><span class="operator">+</span>————<span class="operator">-</span><span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"><span class="operator">|</span> requesting_trx_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">18</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#请求锁的事务ID</span><br><span class="line"><span class="operator">|</span> requested_lock_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">81</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#请求锁的锁ID</span><br><span class="line"><span class="operator">|</span> blocking_trx_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">18</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#当前拥有锁的事务ID</span><br><span class="line"><span class="operator">|</span> blocking_lock_id <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">81</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span>#当前拥有锁的锁ID</span><br><span class="line"><span class="operator">+</span>——————<span class="operator">-</span><span class="operator">+</span>————<span class="operator">-</span><span class="operator">+</span>——<span class="operator">+</span>—–<span class="operator">+</span>———<span class="operator">+</span>——<span class="operator">-</span><span class="operator">+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据准备：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `c` (`c`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB CHARSET <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> utf8_bin;</span><br><span class="line"><span class="comment">-- 数据准备</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t`(`id`, `c`, `d`) <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t`(`id`, `c`, `d`) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t`(`id`, `c`, `d`) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t`(`id`, `c`, `d`) <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t`(`id`, `c`, `d`) <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t`(`id`, `c`, `d`) <span class="keyword">VALUES</span> (<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.jacian.com/note/img/20210531224743.png" alt="数据"></p><h3 id="锁举例"><a href="#锁举例" class="headerlink" title="锁举例"></a>锁举例</h3><blockquote><p>锁等待超时：ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</p><p>死锁：1213 Deadlock found when trying to get lock</p></blockquote><h4 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h4><table><thead><tr><th>Session 1</th><th>Session 2</th><th>Session 1</th></tr></thead><tbody><tr><td>begin;<br />UPDATE t SET d = d+1 WHERE id=7;</td><td></td><td></td></tr><tr><td></td><td>begin;<br />INSERT INTO t VALUES(8,8,8);  – 阻塞</td><td></td></tr><tr><td></td><td></td><td>begin;<br />INSERT INTO t VALUES(11, 11, 11); – 不阻塞</td></tr></tbody></table><p>分析：</p><ol><li>由于表T没有 <code>id=7</code> 这条记录，加锁单位是 <code>Next-key Lock</code> ，事务1加锁范围是 <code>(5, 10]</code> ，因为 <code>id=7</code> 是一个等值查询，根据优化规则， <code>id=10</code> 不满足条件， <code>Next-key Lock</code> 退化成 <code>Gap Lock</code> ，因此最终加锁范围是 <code>(5, 10)</code> 。</li><li><code>Session2</code> 想要向这个间隙中插入 <code>id=8</code> 的记录必须等待 <code>Session1</code> 事务提交后才可以。</li><li><code>Session3</code> 想要插入 <code>id=11</code> ，不在加锁范围，所以可以插入成功。</li></ol><blockquote><p>这是如果有 <code>Session4</code> 想要更新 <code>id=8</code> 的记录，是可以执行成功的，因为间隙锁之间互不冲突；</p></blockquote><h4 id="非唯一键等值锁"><a href="#非唯一键等值锁" class="headerlink" title="非唯一键等值锁"></a>非唯一键等值锁</h4><table><thead><tr><th>Session 1</th><th>Session 2</th><th>Session 3</th></tr></thead><tbody><tr><td>begin;<br />SELECT id FROM t WHERE c=5 LOCK IN SHARE MODE;</td><td></td><td></td></tr><tr><td></td><td>begin;<br />INERT INTO t VALUES(7,7,7); – 阻塞</td><td></td></tr><tr><td></td><td></td><td>begin;<br />UPDATE t SET d=d+1 WHERE id=5; – 不阻塞</td></tr></tbody></table><p>分析：</p><ol><li><code>Session1</code> 给索引 c 上的 c=5 这一列加上读锁，根据规则1，加锁单位为 <code>Next-key Lock</code> ，因此会给 (0, 5] 区间加上 <code>Next-key Lock</code></li><li>因为c是普通索引，所以访问 c=5 之后还要向右遍历，直到 c=10 停止，根据规则2访问到的都要加锁，所以加锁范围为 (5, 10] ，根据优化2，等值查询退化为 <code>Gap Lock</code> ，变为 (5, 10)，所以最终的加锁范围是 (0, 10)；</li><li><code>Session2</code> 想要插入 id=7 的记录，要等待 <code>Session1</code> 提交之后才可以成功插入，因为 <code>Session1</code> 的间隙范围是(5, 10)；</li><li>根据原则2，访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁。所以 <code>Session3</code> 的语句可以正常执行；</li></ol><blockquote><p>LOCK IN SHARE MODE; 只锁覆盖索引，FOR UPDATE; 会顺便锁上主键索引；</p></blockquote><h4 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><blockquote><p>对于以上两条SQL，加锁的范围不一致，第一条是id=10 的行锁，第二条是 (10, 15] 的 <code>Next-key Lock</code> </p></blockquote><table><thead><tr><th>Session1</th><th>Session2</th><th>Session3</th></tr></thead><tbody><tr><td>begin;<br />select * from t where id&gt;=10 and id&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>begin;<br />insert into t values(9,9,9); – 不阻塞<br />insert into t values(11,11,11); – 阻塞</td><td></td></tr><tr><td></td><td></td><td>update t set d=d+1 where id=15; – 阻塞</td></tr></tbody></table><p>分析：</p><ol><li><code>Session1</code> 根据规则1，加锁单位为 <code>Next-key Lock</code> ，因为 id&gt;=10 是范围查询，直到找到 id=15 停止，最终 <code>Session1</code> 的加锁范围是 (10, 15]</li><li><code>Session3</code> 当去 update 一个存在的值是，给该行添加 <code>Record Lock</code> ，由于 <code>Record Lock</code> 和 <code>Next-key Lock</code> 不兼容，所以阻塞</li></ol><blockquote><p>如果 <code>Session3</code> 更新一个 (10, 15) 的值，则会阻塞；</p></blockquote><h4 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h4><table><thead><tr><th>Session1</th><th>Session2</th><th>Session3</th></tr></thead><tbody><tr><td>begin;<br />select * from t where c&gt;=10 and c&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>begin;<br />insert into t values(8,8,8); – 阻塞</td><td></td></tr><tr><td></td><td></td><td>begin;<br />update t set d=d+1 where c=15; – 阻塞</td></tr></tbody></table><p>分析：</p><ol><li><code>Session1</code> 给索引c加上了 (5,10], (10,15] 两个 <code>Next-key Lock</code> ；由于是范围查询，不触发优化，不会退化成间隙锁</li></ol><h4 id="非唯一索引等值锁for-Update"><a href="#非唯一索引等值锁for-Update" class="headerlink" title="非唯一索引等值锁for Update"></a>非唯一索引等值锁for Update</h4><p>数据准备：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t1` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t1` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t1` <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t1` <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t1` <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在表t中，a列有普通索引，所以可能锁定的范围有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="operator">-</span>∞, <span class="number">1</span>], (<span class="number">1</span>, <span class="number">3</span>], (<span class="number">3</span>, <span class="number">5</span>], (<span class="number">5</span>, <span class="number">8</span>], (<span class="number">8</span>, <span class="number">11</span>], (<span class="number">11</span>, <span class="operator">+</span>∞)</span><br></pre></td></tr></table></figure><table><thead><tr><th>session1</th><th>session2</th></tr></thead><tbody><tr><td>begin;<br />select * from t1 where a=8 for update;</td><td></td></tr><tr><td></td><td>begin;<br />insert into t1 (a) values (12); – 不会阻塞<br />insert into t1 (a) values (11); – 不会阻塞<br />insert into t1 (a) values (4); – 不会阻塞<br />insert into t1 (a) values (5); – 阻塞</td></tr><tr><td></td><td></td></tr></tbody></table><p><code>Session1</code> 执行完成之后预期加锁范围为 (5, 8] 和 (8, 11]，由于锁优化策略，退化成间隙锁，范围变成 (5, 8] 和 (8, 11) ，也就是 (5, 11) ，插入12和4不会阻塞很好理解。但是 5不在锁的范围内，还是被锁上了</p><p>是因为如果索引值相同的话，会根据id进行排序加锁，所以最终的加锁范围是索引a的 (5, 4) 到 (11, 6) 的范围</p><p><img src="https://img.jacian.com/note/img/20210609234749.jpg" alt="锁范围"></p><h3 id="死锁模拟"><a href="#死锁模拟" class="headerlink" title="死锁模拟"></a>死锁模拟</h3><h4 id="死锁模拟-场景1"><a href="#死锁模拟-场景1" class="headerlink" title="死锁模拟-场景1"></a>死锁模拟-场景1</h4><p>AB BA操作问题</p><p>数据准备：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stu_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `score` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_uniq_stu_num` (`stu_num`),</span><br><span class="line">  KEY `idx_score` (`score`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(id, stu_num, score) <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">11</span>, <span class="number">111</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(id, stu_num, score) <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">22</span>, <span class="number">222</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(id, stu_num, score) <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">33</span>, <span class="number">333</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>begin;<br />select * from t2 where id = 1 for update;</td><td></td></tr><tr><td></td><td>begin;<br />select * from t2 where id = 2 for update;</td></tr><tr><td>select * from t2 where id = 2 for update;</td><td></td></tr><tr><td></td><td>select * from t2 where id = 1 for update; – Deadlock</td></tr></tbody></table><h4 id="死锁模拟-场景2"><a href="#死锁模拟-场景2" class="headerlink" title="死锁模拟-场景2"></a>死锁模拟-场景2</h4><p>S-lock 升级 X-lock</p><p>数据准备：</p><blockquote><p>沿用简单场景1数据</p></blockquote><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>begin;<br />SELECT * FROM t2 WHERE id = 1 LOCK IN SHARE MODE;</td><td></td></tr><tr><td></td><td>begin;<br />DELETE FROM t2 WHERE id = 1;</td></tr><tr><td>DELETE FROM t2 WHERE id = 1;</td><td></td></tr></tbody></table><p>分析：</p><ol><li>Session1 获取到 S-Lock</li><li>Session2 尝试获取到 X-Lock ，但是被 Session1 的S-Lock 阻塞</li><li>Session1 想要获取到 X-Lock，本身拥有一个 S-Lock ，但是Session2 申请 X-Lock 在前，需要等待 Session2 释放之后才能提升到 X-Lock，两个事务造成资源争抢导致死锁</li></ol><h4 id="死锁模拟-场景3"><a href="#死锁模拟-场景3" class="headerlink" title="死锁模拟-场景3"></a>死锁模拟-场景3</h4><p>数据准备：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  a <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">  <span class="keyword">unique</span> key ua(a)</span><br><span class="line">) engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3(id,a) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="number">4</span>),(<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>Session 1</th><th>Session 2</th></tr></thead><tbody><tr><td></td><td>insert into t3(id,a) values(26,10);</td></tr><tr><td>insert into t3(id,a) values(30,10);</td><td></td></tr><tr><td></td><td>insert into t3(id,a) values(40,9);</td></tr></tbody></table><p>分析：</p><p>事务一在插入时由于跟事务二插入的记录唯一键冲突，所以对 a=10 这个唯一索引加 S 锁（Next-key）并处于锁等待，事务二再插入 a=9 这条记录，需要获取插入意向锁（lock_mode X locks gap before rec insert intention）和事务一持有的 Next-key 锁冲突，从而导致死锁。</p><h4 id="死锁模拟-场景4"><a href="#死锁模拟-场景4" class="headerlink" title="死锁模拟-场景4"></a>死锁模拟-场景4</h4><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>begin;</td><td>begin;</td></tr><tr><td>UPDATE t SET d = d+1 WHERE id=7;</td><td></td></tr><tr><td></td><td>UPDATE t SET d = d+1 WHERE id=9;</td></tr><tr><td>INSERT INTO t VALUES(8,8,8);</td><td></td></tr><tr><td></td><td>INSERT INTO t VALUES(8,8,8);</td></tr></tbody></table><p>两条语句的执行计划：</p><p><img src="https://img.jacian.com/note/img/20210531211847.png" alt="语句执行计划"></p><p>事务1执行 INSERT 时的锁情况：</p><p><img src="https://img.jacian.com/note/img/20210528003314.png" alt="锁情况"></p><p>死锁日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-05-28 00:07:00 0x70000a09a000</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1518, ACTIVE 17 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 24, OS thread handle 123145470435328, query id 2673 localhost root update</span><br><span class="line">INSERT INTO t VALUES(8,8,8)</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 27 page no 3 n bits 80 index PRIMARY of table `lock_demo`.`t` trx id 1518 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000005d0; asc       ;;</span><br><span class="line"> 2: len 7; hex 2c0000014a01ca; asc ,   J  ;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000000b; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1519, ACTIVE 12 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 25, OS thread handle 123145470713856, query id 2674 localhost root update</span><br><span class="line">INSERT INTO t VALUES(8,8,8)</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 27 page no 3 n bits 80 index PRIMARY of table `lock_demo`.`t` trx id 1519 lock_mode X locks gap before rec</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000005d0; asc       ;;</span><br><span class="line"> 2: len 7; hex 2c0000014a01ca; asc ,   J  ;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000000b; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 27 page no 3 n bits 80 index PRIMARY of table `lock_demo`.`t` trx id 1519 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000005d0; asc       ;;</span><br><span class="line"> 2: len 7; hex 2c0000014a01ca; asc ,   J  ;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000000b; asc     ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure><ol><li>UPDATE 的 WHERE 子句没有满足条件的记录，而<strong>对于不存在的记录 并且在RR级别</strong>下，UPDATE 加锁类型为间隙锁（Gap Lock），间隙锁（Gap Lock）之间是兼容的，所以两个事务都能成功执行 UPDATE；这里的gap范围是索引id列 (5, 10) 的范围。</li><li>INSERT 时，其加锁过程为先在插入间隙上获取插入意向锁，插入数据后再获取插入行上的排它锁。又插入意向锁与间隙锁（Gap Lock）和临键锁（Next-key Lock）冲突，即一个事务想要获取插入意向锁，如果有其他事务已经加了（Gap Lock）或临键锁（Next-key Lock），则会阻塞。</li><li>场景中两个事务都持有间隙锁（Gap Lock），然后又申请插入意向锁，此时都被阻塞，循环等待造成死锁。</li></ol><blockquote><ul><li><p>记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap</p></li><li><p>间隙锁（LOCK_GAP）: lock_mode X locks gap before rec</p></li><li><p>Next-key 锁（LOCK_ORNIDARY）: lock_mode X</p></li><li><p>插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention</p></li></ul><p>并不是在日志里看到 lock_mode X 就认为这是 Next-key 锁，因为还有一个例外：如果在 supremum record 上加锁，<code>locks gap before rec</code> 会省略掉，间隙锁会显示成 <code>lock_mode X</code>，插入意向锁会显示成 <code>lock_mode X insert intention</code>。</p></blockquote><hr><p>INSERT 语句，会尝试获取<code> lock mode S waiting</code> 锁，这是为了检测唯一键是否重复，必须进行一次当前读，要加 S 锁。</p><p>INSERT 加锁分几个阶段：先检查唯一键约束，加 S 锁，再加插入意向锁，最后插入成功时升级为 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前事务信息：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX;</span><br><span class="line"><span class="comment">-- 查看当前锁定的事务</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line"><span class="comment">-- 查看当前等待锁的事务</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><p><img src="https://img.jacian.com/note/img/20210528012425.png" alt="向大佬低头"></p><p><strong>参考链接：</strong></p><p>MySQL官方团队：<a href="https://mysqlserverteam.com/innodb-data-locking-part-3-deadlocks/">https://mysqlserverteam.com/innodb-data-locking-part-3-deadlocks/</a></p><p>MySQL锁官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p><p>死锁排查分析：<a href="https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html">https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html</a></p><p>死锁场景罗列：<a href="https://github.com/aneasystone/mysql-deadlocks">https://github.com/aneasystone/mysql-deadlocks</a></p><p>插入意向锁和Next-Key引起的死锁：<a href="https://segmentfault.com/a/1190000019745324">https://segmentfault.com/a/1190000019745324</a></p><p>透过源码分析INSERT加锁流程：<a href="https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html">https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构原理</title>
      <link href="/2021/06/12/5bb8aee08c1b/"/>
      <url>/2021/06/12/5bb8aee08c1b/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL体系架构"><a href="#MySQL体系架构" class="headerlink" title="MySQL体系架构"></a>MySQL体系架构</h2><p><img src="https://img.jacian.com/note/img/20210606204741.png" alt="MySQL体系架构"></p><p>MySQL Server的架构可以分为以下四层：网络连接层、服务层、存储引擎层和系统文件层。</p><h3 id="网络连接层"><a href="#网络连接层" class="headerlink" title="网络连接层"></a>网络连接层</h3><h4 id="客户端连接器"><a href="#客户端连接器" class="headerlink" title="客户端连接器"></a>客户端连接器</h4><p>提供与MySQL服务器连接的支持，支持市面上的主流语言。例如：Java、Python等，它们通过各自的API与MySQL建立连接。</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>服务层是MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优化器、缓存六个部分。</p><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>负责管理与客户端与服务端的连接，一个线程负责管理一个连接。</p><h4 id="系统管理和控制工具"><a href="#系统管理和控制工具" class="headerlink" title="系统管理和控制工具"></a>系统管理和控制工具</h4><p>备份恢复、安全管理、集群管理等。</p><h4 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h4><p>用于接收客户端的SQL指令（DDL、DML、存储过程、视图等），返回用户需要的结果信息。</p><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><p>负责将客户端的SQL指令解析生成一个解析树。然后根据一些SQL规则检查解析树是否合法。</p><h4 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h4><p>解析树通过解析器的检查后，交由查询优化器来生成执行计划，与存储引擎层进行交互。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存机制是由一系列小缓存组成的：表缓存、记录缓存、权限缓存、引擎缓存等。如果查询命中缓存则可以直接从缓存中获取结果直接返回。</p><h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p>存储引擎负责MySQL中数据的存储与提取，与系统文件进行交互。MySQL的存储引擎是插件式的。服务器的查询执行通过接口与存储引擎层进行交互，接口屏蔽了不同存储引擎之间的差异。</p><h3 id="系统文件层"><a href="#系统文件层" class="headerlink" title="系统文件层"></a>系统文件层</h3><p>该层主要负责将数据库的数据和日志存储在文件系统上，并完成与存储引擎的交互，是文件的物理存储层。包括：日志文件、数据文件、配置文件、PID文件、socket文件等。</p><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><ol><li>错误日志：默认开启，通过 <code>show variables like &#39;%log_error%&#39;;</code> 查看存储位置</li><li>通用查询日志：记录一般的查询日志，通过 <code>show variables like &#39;%general%&#39;;</code> 查看存储位置及开关状态</li><li>二进制文件（binlog）：记录了对MySQL数据库执行的更改操作，并且记录的语句发生时间、执行时长；它不记录SELECT、show等不修改数据库信息的SQL。主要用于数据恢复和主从复制。<ul><li><code>show variables like &#39;%log_bin%&#39;;</code> //是否开启 </li><li><code>show variables like &#39;%binlog%&#39;;</code> //参数查看 </li><li><code>show binary logs;</code> //查看日志文件</li></ul></li><li>慢查询日志：记录所有查询时长超时的查询SQL，默认10s。<ul><li><code>show variables like &#39;%slow_query%&#39;;</code> //是否开启 </li><li><code>show variables like &#39;%long_query_time%&#39;;</code> //时长</li></ul></li></ol><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等。</p><h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><ol><li>dp.opt：记录整个数据库的默认字符集及排序规则。</li><li>frm文件：存储与表相关的元数据信息，包括表结构的定义信息等；每张表都会有一个自己的frm文件。</li><li>myd文件：MyISAM存储引擎专用。存储MyISAM表的数据，每张表都会有一个MYD文件。</li><li>myi文件：MyISAM存储引擎专用。存储MyISAM表的索引相关信息，每一张表对应一个MYI文件。</li><li>ibd和ibdata文件：存储InnoDB的数据文件（包括索引）。InnoDB存储引擎有两种表空间方式：独享表空间和共享表空间。独享表空间使用ibd文件存储，每张表对应一个ibd文件。共享表空间使用ibdata文件存储，所有表共用一个（或多个，可修改配置）ibdata文件。</li><li>ibdata1文件：系统表空间数据文件，存储表元数据、Undo日志等 。</li><li>ib_logﬁle0、ib_logﬁle1 文件：Redo log 日志文件。</li></ol><h4 id="PID文件"><a href="#PID文件" class="headerlink" title="PID文件"></a>PID文件</h4><p>存放服务器进程的进程ID</p><h4 id="socket文件"><a href="#socket文件" class="headerlink" title="socket文件"></a>socket文件</h4><p>socket 文件也是在 Unix/Linux 环境下才有的，用户在 Unix/Linux 环境下客户端连接可以不通过 TCP/IP 网络而直接使用 Unix Socket 来连接 MySQL。</p><h2 id="MySQL运行机制"><a href="#MySQL运行机制" class="headerlink" title="MySQL运行机制"></a>MySQL运行机制</h2><p><img src="https://img.jacian.com/note/img/20210606213605.jpg" alt="查询流程"></p><ol><li>建立连接：通过客户端/服务器通信协议与MySQL建立连接，MySQL客户端与服务端的通信方式是半双工，对于每一个客户端的连接，都标记着他们正在做什么。</li><li>查询缓存：这是MySQL的一个可优化查询的地方，如果开启了查询缓存，且在缓存中存在完全相同的SQL，则将查询结果直接返回给客户端。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。因为只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或 <code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！<ul><li><code>select variables like &#39;%query_cache%&#39;;</code> 查询缓存是否启用、空间大小、限制等。</li><li><code>show status like &#39;Qcache%&#39;;</code> 查询更详细的缓存参数，可用缓存空间、缓存块、缓存使用大小等。</li></ul></li><li>解析器：将客户端发送的SQL进行语法解析，生成解析树；预处理器进一步检查解析树是否合法，例如：数据表和数据列是否存在、名字或者别名是否有歧义；然后生成新的解析树。as单法令jalwekkjadlskjgklajerlkjalksdjlkjfalkejlkajtlkqjwelktjlaalsdjfljasdlfjklajsdfljalalsdkkkekwkwkkwkwjjfjfjfjfaksdjfaljsdl</li><li>查询优化器：根据生成的解析树生成最优的执行计划。MySQL根据优化策略生成最优的执行计划，可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。<ul><li>等价变换策略：5=5 and a&gt;5 换成 a&gt;5；a = 5 and b&lt;a 换成 a=5 and b&lt;5；基于联合索引调整查询条件顺序；</li><li>优化 count、min、max函数：InnoDB引擎min函数只需要找索引最左边；InnoDB引擎max函数只需要找索引最右边；MyISAM引擎count(*)，不需要计算，直接返回；</li><li>提前终止查询：使用了limit查询，获取limit所需的数据，就不在继续遍历后面数据</li><li>in的优化：MySQL对in查询，会先进行排序，再采用二分法查找数据。比如：where id in (2,1,3)，变 成 where id in (1,2,3)</li></ul></li><li>查询执行引擎负责执行 SQL 语句：此时查询执行引擎会根据SQL中表的存储引擎类型，以及对应的API接口与底层存储引擎缓存或者物理文件的交互，获得查询结果并返回给客户端。如果开启了查询缓存，会先将查询SQL和查询结果完整的保存到查询缓存中，以后若有相同的查询语句执行则直接将结果在缓存中获取并返回；如果返回结果过多采用增量模式返回；</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper源码环境搭建</title>
      <link href="/2020/12/31/402df3477423/"/>
      <url>/2020/12/31/402df3477423/</url>
      
        <content type="html"><![CDATA[<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>本文以 <code>Zookeeper 3.5.4</code> 为例，源码下载地址：<a href="https://github.com/apache/zookeeper/tree/release-3.5.4">https://github.com/apache/zookeeper/tree/release-3.5.4</a></p><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p>在命令行使用 <code>ant</code> 编译的时候出现了一些问题，在网上没有找到解决方案，所以使用 idea 进行编译，希望有知道原因的大佬指点迷津，下图为执行 <code>ant eclipse</code> 后的报错信息</p><p><img src="https://img.jacian.com/note/img20201231150258.png" alt="image-20201231150258597"></p><blockquote><p>下边是具体操作步骤</p></blockquote><p>首先使用 idea 打开项目</p><p><img src="https://img.jacian.com/note/img20201231142101.png" alt="image-20201231142101629"></p><p>右击 <code>build.xml</code> ，选择 <code>Add as Ant Build File</code> </p><p><img src="https://img.jacian.com/note/img20201231142149.png" alt="image-20201231142149848"></p><p>展开右侧 <code>Ant</code> 侧边栏，双击 <code>eclipse</code> </p><p><img src="https://img.jacian.com/note/img20201231142311.png" alt="image-20201231142311413"></p><p>等待 build 完成，时间根据自身网络环境而定</p><p><img src="https://img.jacian.com/note/img20201231142347.png" alt="image-20201231142347703"></p><p>编译完成后会产生eclipse 的配置文件</p><p><img src="https://img.jacian.com/note/img20201231142516.png" alt="image-20201231142516118"></p><h2 id="源码导入"><a href="#源码导入" class="headerlink" title="源码导入"></a>源码导入</h2><p>这时关掉项目窗口，选择 <code>File --&gt; New --&gt; Project from Existing Sources...</code></p><p><img src="https://img.jacian.com/note/img20201231142808.png" alt="image-20201231142808610"></p><p>选择项目目录，选择导入Eclipse项目，然后一路 Next </p><p><img src="https://img.jacian.com/note/img20201231142925.png" alt="image-20201231142924975"></p><p>这时候源码就导入成功了~</p><h2 id="启动Zookeeper服务端"><a href="#启动Zookeeper服务端" class="headerlink" title="启动Zookeeper服务端"></a>启动Zookeeper服务端</h2><p>针对单机版本和集群版本，分别对应两个启动类：</p><ul><li>单机：ZooKeeperServerMain</li><li>集群：QuorumPeerMain</li></ul><p>这里只做单机版测试</p><p>在 <code>conf</code> 目录下复制一份 <code>zoo_sample.cfg</code> 并重命名为 <code>zoo.cfg</code></p><p><img src="https://img.jacian.com/note/img20201231143409.png" alt="image-20201231143409237"></p><p>配置主启动类，选择 <code>Add Configuration</code></p><p><img src="https://img.jacian.com/note/img20201231143511.png" alt="image-20201231143511158"></p><p>选择添加一个 <code>Application</code> </p><p><img src="https://img.jacian.com/note/img20201231143604.png" alt="image-20201231143604156"></p><blockquote><p>图中 <code>1</code> 为 <code>VM options</code> ； <code>2</code> 为 <code>Main Class</code> ； <code>3</code> 为 <code>Program arguments</code> </p><p>如果2020 版本找不到<code> VM options</code> 点击右上方的 <code>Modify options --&gt; Add VM options</code> 即可</p><p>如果2020 版本找不到<code> VM options</code> 点击右上方的 <code>Modify options --&gt; Add VM options</code> 即可</p><p>如果2020 版本找不到<code> VM options</code> 点击右上方的 <code>Modify options --&gt; Add VM options</code> 即可</p></blockquote><p>具体配置如下</p><p><img src="https://img.jacian.com/note/img20201231144252.png" alt="image-20201231144252187"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主类全路径： org.apache.zookeeper.server.quorum.QuorumPeerMain</span><br></pre></td></tr></table></figure><p>运行配置好的 Application，看到日志输出代表启动成功</p><p><img src="https://img.jacian.com/note/img20201231144447.png" alt="image-20201231144447861"></p><h2 id="启动Zookeeper客户端"><a href="#启动Zookeeper客户端" class="headerlink" title="启动Zookeeper客户端"></a>启动Zookeeper客户端</h2><p>通过运行 <code>QuorumPeerMain</code> 得到的日志，可以得知ZooKeeper服务端已经启动，服务的地址为<code>127.0.0.1:2182</code>。启动客户端来进行连接测试。</p><p>客户端的启动类为<code>org.apache.zookeeper.ZooKeeperMain</code>，进行如下配置：</p><p>同样的增加一个 <code>Application</code></p><p><img src="https://img.jacian.com/note/img20201231145312.png" alt="image-20201231145312089"></p><p>运行配置好的 Application</p><p><img src="https://img.jacian.com/note/img20201231145443.png" alt="image-20201231145443172"></p><p>可以看到已经连接成功，并且可以键入命令；</p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper一致性协议——ZAB</title>
      <link href="/2020/12/30/b40d5e3edd17/"/>
      <url>/2020/12/30/b40d5e3edd17/</url>
      
        <content type="html"><![CDATA[<h2 id="ZAB协议简介"><a href="#ZAB协议简介" class="headerlink" title="ZAB协议简介"></a>ZAB协议简介</h2><p>Zookeeper通过ZAB保证分布式事务的最终一致性。</p><p>ZAB全称Zookeeper Atomic Broadcast（ZAB，Zookeeper原子消息广播协议）</p><ol><li><p>ZAB是一种专门为Zookeeper设计的一种支持 <strong>崩溃恢复</strong> 的 <strong>原子广播协议</strong> ，是Zookeeper保证数据一致性的核心算法。ZAB借鉴了Paxos算法，但它不是通用的一致性算法，是特别为Zookeeper设计的。</p></li><li><p>基于ZAB协议，Zookeeper实现了⼀种主备模式的系统架构来保持集群中各副本之间的数据的⼀致性，表现形式就是使⽤⼀个单⼀的主进程（Leader服务器）来接收并处理客户端的所有事务请求（写请求），并采⽤ZAB的原⼦⼴播协议，将服务器数据的状态变更为事务 Proposal的形式⼴播到所有的Follower进程中。</p></li></ol><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><ul><li>主从架构下，leader 崩溃，数据一致性怎么保证？</li><li>选举 leader 的时候，整个集群无法处理写请求的，如何快速进行 leader 选举？</li></ul><h2 id="ZAB过程"><a href="#ZAB过程" class="headerlink" title="ZAB过程"></a>ZAB过程</h2><p>ZAB协议的核⼼是 <strong>定义了对于那些会改变Zookeeper服务器数据状态的事务请求的处理⽅式</strong></p><p><img src="https://img.jacian.com/note/img20201228214732.png"></p><p>所有事务必须由一个 <strong>全局唯一的服务器来协调处理</strong> ，这样的服务器被称为Leader服务器，余下的服务器则称为Follower服务器</p><ol><li>Leader服务器负责将一个客户端事务请求转化为一个事务Proposal（提案），并将该Proposal分发给集群中所有的Follower服务器</li><li>Leader服务器等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，Leader就会向所有的Follower服务器发送Commit消息，要求将前一个Proposal进行提交。</li></ol><h2 id="ZAB协议内容简介"><a href="#ZAB协议内容简介" class="headerlink" title="ZAB协议内容简介"></a>ZAB协议内容简介</h2><p>ZAB协议包括两种基本的模式： <strong>崩溃恢复</strong> 和 <strong>消息广播</strong></p><h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>当集群中有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入 <strong>消息广播模式</strong> 。</p><p>当一台遵守ZAB协议的服务器启动后加入到集群中，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么加入的服务器会自觉的进入 <strong>数据恢复模式： 找到Leader 所在的服务器，并与其进⾏数据同步，数据同步完成后参与到消息⼴播流程中。</strong></p><p>ZAB协议的消息广播使用原子广播协议， <strong>类似一个二阶段提交的过程</strong> ，但又有所不同。</p><ol><li>二阶段提交中，需要所有参与者反馈ACK后再发送Commit请求。要求所有参与者要么成功，要么失败。这样会产生严重的阻塞问题</li><li>ZAB协议中，Leader等待半数以上的Follower成功反馈ACK即可，不需要收到全部的Follower反馈ACK。</li></ol><p><strong>消息广播过程：</strong></p><ol><li>客户端发起写请求</li><li>Leader将客户端请求信息转化为事务Proposal，同时为每个Proposal分配一个事务ID（Zxid）</li><li>Leader为每个Follower单独分配一个FIFO的队列，将需要广播的Proposal依次放入到队列中</li><li>Follower接收到Proposal后，首先将其以事务日志的方式写入到本地磁盘中，写入成功后给Leader反馈一个ACK响应</li><li>Leader接收到半数以上Follower的ACK响应后，即认为消息发送成功，可以发送Commit消息</li><li>Leader向所有Follower广播Commit消息，同时自身也会完成事务提交。Follower接收到Commit消息后也会完成事务的提交</li></ol><p><img src="https://img.jacian.com/note/img20201229220334.jpg"></p><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>在整个服务框架启动过程中，如果Leader服务器出现网络中断、崩溃退出或重启等异常情况，ZAB协议就会进入崩溃恢复模式。同时选举出新的Leader服务器。</p><p>当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步（数据同步）之后，ZAB协议会退出恢复模式。  </p><ol><li>在ZAB协议中，为了保证程序的正确运⾏，整个恢复过程结束后需要选举出⼀个新的Leader 服务器。</li><li>Leader选举算法不仅仅需要让Leader⾃身知道已经被选举为Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产⽣出来的新Leader服务器。</li></ol><h3 id="ZAB保证数据一致性"><a href="#ZAB保证数据一致性" class="headerlink" title="ZAB保证数据一致性"></a>ZAB保证数据一致性</h3><p>ZAB协议规定了 <strong>如果⼀个事务Proposal在⼀台机器上被处理成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。</strong> 针对这些情况ZAB协议需要保证以下条件：</p><ul><li><p>已经在Leader服务器上提交的事务最终被所有服务器都提交。</p><p>  假设⼀个事务在 Leader 服务器上被提交了，并且已经得到过半 Folower 服务器的Ack反馈，但是在它 将Commit消息发送给所有Follower机器之前，Leader服务器挂了</p></li><li><p>丢弃只在Leader服务器上被提出（未提交）的事务。</p><p>  假设初始的 Leader 服务器 Server1 在提出了⼀个事务Proposal3 之后就崩溃退出 了，从⽽导致集群中的其他服务器都没有收到这个事务Proposal3。于是，当 Server1 恢复过来再次加 ⼊到集群中的时候，ZAB 协议需要确保丢弃Proposal3这个事务。</p></li></ul><p><strong>综上所述，ZAB的选举出来的Leader必须满足以下条件：</strong></p><p>能够确保提交已经被 Leader 提交的事务 Proposal，同时丢弃已经被跳过的事务 Proposal。即：</p><ol><li><strong>新选举出来的 Leader 不能包含未提交的 Proposal。</strong> </li><li><strong>新选举的 Leader 节点中含有最大的 zxid</strong> 。</li></ol><h3 id="ZAB如何数据同步"><a href="#ZAB如何数据同步" class="headerlink" title="ZAB如何数据同步"></a>ZAB如何数据同步</h3><p>所有正常运行的服务器要么成为Leader，要么成为Follower并和Leader保持同步。</p><ol><li><p>完成Leader选举（新的 Leader 具有最高的zxid）之后，在正式开始⼯作（接收客户端请求）之前，Leader服务器会⾸先确认事务⽇志中的所有Proposal是否都已经被集群中过半的机器提交了，即 <strong>是否完成数据同步</strong> 。</p></li><li><p>Leader服务器需要确保所有的Follower服务器能够接收到每⼀条事务Proposal，并且能够正确地将所有已经提交了的事务Proposal应⽤到内存数据中。等到 Follower服务器将所有其尚未同步的事务 Proposal 都从 Leader 服务器上同步过来并成功应⽤到本地数据库中后，Leader服务器就会将该Follower服务器加⼊到真正的可⽤Follower列表中，并开始之后的其他流程。</p></li></ol><h2 id="ZAB运行时状态"><a href="#ZAB运行时状态" class="headerlink" title="ZAB运行时状态"></a>ZAB运行时状态</h2><p>ZAB协议设计中，每个进程都有可能处于如下三种状态之一：</p><ul><li>LOOKING：Leader选举状态，正在寻找Leader</li><li>FOLLOWING：当前节点是Follower。与Leader服务器保持同步状态</li><li>LEADING：当前节点是Leader，作为主进程领导状态。</li></ul><h3 id="ZAB状态的切换"><a href="#ZAB状态的切换" class="headerlink" title="ZAB状态的切换"></a>ZAB状态的切换</h3><p><strong>启动时的状态转换</strong></p><ol><li><p>所有进程的初始状态都是LOOKING状态，此时不存在Leader。</p></li><li><p>接下来，进程会试图选举出来一个新的Leader，Leader切换为LEADING状态，其它进程发现已经选举出新的Leader，那么它就会切换到FOLLOWING状态，并开始与Leader保持同步。</p></li><li><p>处于FOLLOWING状态的进程称为Follower，LEADING状态的进程称为Leader。</p></li><li><p>当Leader崩溃或者放弃领导地位时，其余的Follower进程就会切换到LOOKING状态开始新一轮的Leader选举。</p></li></ol><p><strong>运行过程中的状态转换</strong></p><p><strong>一个Follower只能和一个Leader保持同步，Leader进程和所有的Follower进程之间通过心跳监测机制来感知彼此的情况。</strong></p><ol><li>若Leader能够在超时时间内正常的收到心跳检测，那么Follower就会一直与该Leader保持连接。</li><li>如果在指定时间内Leader无法从过半的Follower进程那里接收到心跳检测，或者TCP连接断开，那么Leader会放弃当前周期的领导，并转换为LOOKING状态；其他的Follower也会选择放弃这个Leader，同时转换为LOOKING状态，之后会进行新一轮的Leader选举</li></ol><h2 id="ZAB的四个阶段"><a href="#ZAB的四个阶段" class="headerlink" title="ZAB的四个阶段"></a>ZAB的四个阶段</h2><h3 id="选举阶段（Leader-Election）"><a href="#选举阶段（Leader-Election）" class="headerlink" title="选举阶段（Leader Election）"></a>选举阶段（Leader Election）</h3><p>节点在一开始都处于选举阶段，只要有一个节点超过半数阶段的票数，它就可以当选准Leader，<strong>只有到达第三个阶段（同步阶段），这个准Leader才会成为真正的Leader。</strong></p><blockquote><p><strong>这一阶段的目的就是为了选出一个准Leader，然后进入下一阶段。</strong></p></blockquote><h3 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h3><p>在这个阶段中，Followers和上一轮选举出的准Leader进行通信，同步Followers最近接受的事务Proposal。这个阶段主要目的是发现当前大多数节点接受的最新提议，并且准Leader生成新的epoch，让Followers接受，更新它们的acceptedEpoch。</p><p>一个Follower只会连接一个Leader，如果有一个节点F认为另一个Follower P是Leader，F在尝试连接P时会被拒绝，F被拒绝后，就会进入选举阶段。</p><p><img src="https://img.jacian.com/note/img20201230163738.jpg" alt="ZAB-发现阶段"></p><h3 id="同步阶段"><a href="#同步阶段" class="headerlink" title="同步阶段"></a>同步阶段</h3><p><strong>同步阶段主要是利用 Leader 前一阶段获得的最新 Proposal 历史，同步集群中所有的副本</strong>。</p><p>只有当 quorum（超过半数的节点） 都同步完成，准 Leader 才会成为真正的 Leader。Follower 只会接收 zxid 比自己 lastZxid 大的 Proposal。</p><p><img src="https://img.jacian.com/note/img20201230165146.jpg" alt="ZAB同步阶段"></p><h3 id="广播阶段"><a href="#广播阶段" class="headerlink" title="广播阶段"></a>广播阶段</h3><p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 Leader 可以进行消息广播。同时，如果有新的节点加入，还需要对新节点进行同步。<br> 需要注意的是，Zab 提交事务并不像 2PC 一样需要全部 Follower 都 Ack，只需要得到 quorum（超过半数的节点）的Ack 就可以。</p><p><img src="https://img.jacian.com/note/img20201230165509.jpg" alt="ZAB广播阶段"></p><h2 id="ZAB协议实现"><a href="#ZAB协议实现" class="headerlink" title="ZAB协议实现"></a>ZAB协议实现</h2><p> Java 版本的ZAB协议的实现跟上面的定义略有不同，选举阶段使用的是 <strong>Fast Leader Election</strong>（FLE），它包含了步骤2的发现职责。因为FLE会选举拥有最新提议的历史节点作为 Leader，这样就省去了发现最新提议的步骤。</p><p>实际的实现将 <strong>发现和同步阶段合并为 Recovery Phase（恢复阶段）</strong> ，所以，Zab 的实现实际上有三个阶段。</p><h3 id="快速选举（Fast-Leader-Election）"><a href="#快速选举（Fast-Leader-Election）" class="headerlink" title="快速选举（Fast Leader Election）"></a>快速选举（Fast Leader Election）</h3><p>前面提到的 FLE 会选举拥有最新Proposal history （lastZxid最大）的节点作为 Leader，这样就省去了发现最新提议的步骤。 <strong>这是基于拥有最新提议的节点也拥有最新的提交记录</strong></p><p><strong>成为Leader的条件：</strong></p><ol><li>选epoch最大的</li><li>epoch相等，选zxid最大的</li><li>epoch和zxid都相等，选server_id最大的（zoo.cfg 中配置的 myid）</li></ol><p>节点在选举开始时，都默认投票给自己，当接收其他节点的选票时，会根据上面的 <strong>Leader条件</strong> 判断并且更改自己的选票，然后重新发送选票给其他节点。<strong>当有一个节点的得票超过半数，该节点会设置自己的状态为 Leading ，其他节点会设置自己的状态为 Following</strong>。</p><p><img src="https://img.jacian.com/note/img20201229225336.png"></p><h3 id="恢复阶段（Recovery-Phase）"><a href="#恢复阶段（Recovery-Phase）" class="headerlink" title="恢复阶段（Recovery Phase）"></a>恢复阶段（Recovery Phase）</h3><p>这一阶段 Follower 发送他们的 lastZxid 给 Leader，Leader 根据 lastZxid 决定如何同步数据。这里的实现跟前面的 阶段 3 有所不同：Follower 收到 TRUNC 指令会终止 <code>L.lastCommitedZxid</code> 之后的 Proposal ，收到 DIFF 指令会接收新的 Proposal。</p><blockquote><p>history.lastCommittedZxid：最近被提交的提议的 zxid<br>history.oldThreshold：被认为已经太旧的已提交提议的 zxid</p></blockquote><p><img src="https://img.jacian.com/note/img20201229225342.png"></p><h3 id="广播阶段（Broadcast-Phase）"><a href="#广播阶段（Broadcast-Phase）" class="headerlink" title="广播阶段（Broadcast Phase）"></a>广播阶段（Broadcast Phase）</h3><blockquote><p>参考 4.1 [ZAB协议内容#消息广播]</p></blockquote><h2 id="ZAB与Paxos的联系和区别"><a href="#ZAB与Paxos的联系和区别" class="headerlink" title="ZAB与Paxos的联系和区别"></a>ZAB与Paxos的联系和区别</h2><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ol><li>都存在一个类似Leader进程的角色，由其负责协调多个Follower进程的运行</li><li>Leader进程都会等待超过半数的Follower作出正确的反馈后，才会将一个提议进行提交（<strong>过半原则</strong>）</li><li>在ZAB中，每个Proposal中都包含了一个epoch值，用来代表当前Leader周期，在Paxos中同样存在这样的一个表示，名字为 Ballot。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>Paxos算法中，新选举产生的主进程会进行两个阶段的工作；第一阶段称为读阶段：新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第二阶段称为写阶段：当前主进程开始提出自己的提议。</li><li>ZAB协议在Paxos基础上添加了同步阶段，此时，新的Leader会确保存在过半的Follower已经提交了之前Leader周期中的所有事物Proposal。这一同步阶段的引入，能够有效保证，Leader在新的周期中提出事务Proposal之前，所有的进程都已经完成了对之前所有事务Proposal的提交。</li></ol><p>总的来说，ZAB协议和Paxos算法的本质区别在于两者的设计目的不一样：ZAB协议主要用于构建一个高可用的分布式数据主备系统，而Paxos算法则用于构建一个分布式的一致性状态机系统。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>问题解答：</p><ul><li><p>主从架构下，leader 崩溃，数据一致性怎么保证？</p><p>  leader 崩溃之后，集群会选出新的 leader，然后就会进入恢复阶段，新的 leader 具有所有已经提交的提议，因此它会保证让 followers 同步已提交的提议，丢弃未提交的提议（以 leader 的记录为准），这就保证了整个集群的数据一致性。</p></li><li><p>选举 leader 的时候，整个集群无法处理写请求的，如何快速进行 leader 选举？</p><p>  这是通过 Fast Leader Election 实现的，leader 的选举只需要超过半数的节点投票即可，这样不需要等待所有节点的选票，能够尽早选出 leader。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper简介</title>
      <link href="/2020/12/29/7136470f45ff/"/>
      <url>/2020/12/29/7136470f45ff/</url>
      
        <content type="html"><![CDATA[<p>Zookeeper是⼀个开源的分布式协调服务，其设计⽬标是将那些复杂的且容易出错的分布式⼀致性服务封装起来，构成⼀个⾼效可靠的原语集，并以⼀些简单的接⼝提供给⽤户使⽤。</p><p>zookeeper是⼀个典型的分布式数据⼀致性的解决⽅案，分布式应⽤程序可以基于它实现诸如数据订阅/发布、负载均衡、命名服务、集群管理、分布式锁和分布式队列等功能。</p><h2 id="zookeeper基本概念"><a href="#zookeeper基本概念" class="headerlink" title="zookeeper基本概念"></a>zookeeper基本概念</h2><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p> <code>Zookeeper</code>  中引入了了 <code>Leader</code> 、  <code>Follower</code> 、 <code>Observer</code> 三种⻆⾊。 <code>Leader</code> 服务器为客户端提供读和写服务，除 <code>Leader</code> 外，其他机器包括 <code>Follower</code> 和  <code>Observer</code>  都能提供读服务。唯⼀的区别在于 <code>Observer</code> 不参与 <code>Leader</code> 选举过程， 不参与写操作的过半写成功策略，因此 <code>Observer</code> 可以在不影响写性能的情况下提升集群的性能。</p><h3 id="会话（session）"><a href="#会话（session）" class="headerlink" title="会话（session）"></a>会话（session）</h3><p>指客户端会话， <strong>⼀个客户端连接是指客户端和服务端之间的⼀个TCP⻓连接</strong> </p><h3 id="数据节点（Znode）"><a href="#数据节点（Znode）" class="headerlink" title="数据节点（Znode）"></a>数据节点（Znode）</h3><p>ZooKeeper将所有数据存储在内存中，数据模型是⼀棵树 （ <code>ZNode Tree</code> ），由斜杠（ <code>/</code> ）进⾏分割的路径，就是⼀个 <code>Znode</code> ，例如 <code>/app/path1</code> 。每个 <code>ZNode</code> 上都 会保存⾃⼰的数据内容，同时还会保存⼀系列属性信息。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p> <code>Zookeeper</code> 会为每个 <code>Znode</code> 维护 ⼀个叫作 <code>Stat </code>的数据结构， <code>Stat</code> 记录了这个 <code>ZNode</code> 的三个数据版本，分别是 <code>version</code> （当前 <code>ZNode</code> 的版 本）、 <code>cversion</code> （当前 <code>ZNode</code> ⼦节点的版本）、 <code>aversion</code> （当前 <code>ZNode</code> 的 <code>ACL</code> 版本）。</p><h3 id="事件监听器（Watcher）"><a href="#事件监听器（Watcher）" class="headerlink" title="事件监听器（Watcher）"></a>事件监听器（Watcher）</h3><p>Wathcer（事件监听器），是Zookeeper中⼀个很重要的特性，Zookeeper允许⽤户在指定节点上注册 ⼀些Watcher，并且在⼀些特定事件触发的时候，Zookeeper服务端会将事件通知到感兴趣的客户端， 该机制是Zookeeper实现分布式协调服务的重要特性</p><h3 id="权限控制（ACL）"><a href="#权限控制（ACL）" class="headerlink" title="权限控制（ACL）"></a>权限控制（ACL）</h3><p>Zookeeper采⽤ACL（Access Control Lists）策略来进⾏权限控制，其定义了如下五种权限：</p><ol><li><strong>CREATE</strong> ：创建⼦节点的权限。</li><li><strong>READ</strong> ：获取节点数据和⼦节点列表的权限。</li><li><strong>WRITE</strong> ：更新节点数据的权限。</li><li><strong>DELETE</strong> ：删除⼦节点的权限。</li><li><strong>ADMIN</strong> ：设置节点ACL的权限。 </li></ol><blockquote><p>其中需要注意的是， <code>CREATE</code> 和 <code>DELETE</code> 这两种权限都是针对⼦节点的权限控制</p></blockquote><h2 id="服务器角色（TODO）"><a href="#服务器角色（TODO）" class="headerlink" title="服务器角色（TODO）"></a>服务器角色（TODO）</h2><h3 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h3><p>Leader服务器是Zookeeper集群工作的核心，主要工作有以下两个：</p><ul><li>事务请求的唯一调度和矗立着，保证集群事务处理的顺序性</li><li>集群内部个服务器的调度者</li></ul><h3 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h3><p>ollower服务器是Zookeeper集群状态中的跟随者，其主要⼯作有以下三个：</p><ol><li><p>处理客户端⾮事务性请求（读取数据），转发事务请求给Leader服务器。</p></li><li><p>参与事务请求Proposal的投票。</p></li><li><p>参与Leader选举投票。</p></li></ol><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer是ZooKeeper⾃3.3.0版本开始引⼊的⼀个全新的服务器⻆⾊。从字⾯意思看，该服务器充当 了⼀个观察者的⻆⾊——其观察ZooKeeper集群的最新状态变化并将这些状态变更同步过来。</p><p> Observer服务器在⼯作原理上和Follower基本是⼀致的，对于⾮事务请求，都可以进⾏独⽴的处理，⽽ 对于事务请求，则会转发给Leader服务器进⾏处理。 <strong>和Follower唯⼀的区别在于，Observer不参与任何形式的投票</strong> ，包括事务请求Proposal的投票和Leader选举投票。简单地讲，Observer服务器只提供 ⾮事务服务，通常⽤于在不影响集群事务处理能⼒的前提下提升集群的⾮事务处理能⼒。</p><h2 id="Zookeeper数据模型——Znode"><a href="#Zookeeper数据模型——Znode" class="headerlink" title="Zookeeper数据模型——Znode"></a>Zookeeper数据模型——Znode</h2><p> <code>Zookeeper</code> 中所有信息都被保存在一个个数据节点上，这些节点被称为 <code>Znode</code> 。 <code>Znode</code>  是 <code>Zookeeper</code> 中最小的存储单元，在 <code>Znode</code> 上又可以挂 <code>Znode</code> ，这样一层一层下去就形成了 Znode 树，称为 <code>Znode Tree</code> 。</p><p><img src="Untitled.assets/img20201228161314.png"></p><h3 id="Znode-的类型"><a href="#Znode-的类型" class="headerlink" title="Znode 的类型"></a>Znode 的类型</h3><ol><li><p><strong>持久节点：</strong> 是Zookeeper中最常⻅的⼀种节点类型，所谓持久节点，就是指节点被创建后会⼀直存在务器，直到删除操作主动清除。</p></li><li><p><strong>持久顺序节点：</strong> 就是有顺序的持久节点，节点特性和持久节点是⼀样的，只是额外特性表现在顺序上。 顺序特性实质是在创建节点的时候，会在节点名后⾯加上⼀个数字后缀，来表示其顺序。</p></li><li><p><strong>临时节点：</strong> 就是会被⾃动清理掉的节点，它的⽣命周期和客户端会话绑在⼀起，客户端会话结束，节点会被删除掉。与持久性节点不同的是，临时节点不能创建⼦节点。</p></li><li><p><strong>临时顺序节点：</strong> 就是有顺序的临时节点，和持久顺序节点相同，在其创建的时候会在名字后⾯加上数字后缀。</p></li></ol><h3 id="Znode的状态信息"><a href="#Znode的状态信息" class="headerlink" title="Znode的状态信息"></a>Znode的状态信息</h3><p><img src="Untitled.assets/img20201228162420.png"></p><p>整个 ZNode 节点内容包括两部分：节点数据内容和节点状态信息。图中【持久节点顺序】 是数据内容，其他的属于状态信息。</p><ul><li>cZxid 就是 Create ZXID，表示节点被创建时的事务ID。 </li><li>ctime 就是 Create Time，表示节点创建时间。 </li><li>mZxid 就是 Modified ZXID，表示节点最后⼀次被修改时的事务ID。 </li><li>mtime 就是 Modified Time，表示节点最后⼀次被修改的时间。 </li><li>pZxid 表示该节点的⼦节点列表最后⼀次被修改时的事务 ID。只有⼦节点列表变更才会更新 pZxid， ⼦节点内容变更不会更新。 </li><li>cversion 表示⼦节点的版本号。 </li><li>dataVersion 表示内容版本号。 </li><li>aclVersion 标识acl版本 ephemeralOwner 表示创建该临时节点时的会话 sessionID，如果是持久性节点那么值为 0 </li><li>dataLength 表示数据⻓度。 </li><li>numChildren 表示直系⼦节点数。</li></ul><h2 id="Watcher-数据变更通知"><a href="#Watcher-数据变更通知" class="headerlink" title="Watcher-数据变更通知"></a>Watcher-数据变更通知</h2><p>Zookeeper使⽤Watcher机制实现分布式数据的发布/订阅功能。⼀个典型的发布/订阅模型系统定义了⼀种 ⼀对多的订阅关系，能够让多个订阅者同时监听某⼀个主题对象，当这个主题对象⾃身状态变化时，会通知所有订阅者，使它们能够做出相应的处理。</p><p>Zookeeper中引入了Watcher机制实现这种分布式的通知功能。Zookeeper允许客户端向服务端注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，那么会向客户端发布一个事件通知来实现分布式的通知功能。</p><p><img src="Untitled.assets/img20201228163122.png"></p><p> <code>Zookeeper</code> 的 <code>Watcher</code> 机制主要包括<strong>客户端线程、客户端WatcherManager、Zookeeper服务器</strong>三部分。</p><p>具体⼯作流程为：</p><ol><li>客户端在向 <code>Zookeeper</code> 服务器注册的，同时会将 <code>Watcher</code> 对象存储在客户端的 <code>WatcherManager</code> 当中。</li><li>当 <code>Zookeeper</code> 服务器触发 <code>Watcher</code> 事件后，会向客户端发送通知。</li><li>客户端线程从 <code>WatcherManager</code> 中取出对应的 <code>Watcher</code> 对象来执⾏回调逻辑。</li></ol><h2 id="ACL-保障数据的安全"><a href="#ACL-保障数据的安全" class="headerlink" title="ACL-保障数据的安全"></a>ACL-保障数据的安全</h2><p>从三个⽅⾯来理解ACL机制：<strong>权限模式（Scheme）、授权对象（ID）、权限 （Permission）</strong>，通常使⽤”scheme: id : permission”来标识⼀个有效的ACL信息。</p><h3 id="权限模式：Scheme"><a href="#权限模式：Scheme" class="headerlink" title="权限模式：Scheme"></a>权限模式：Scheme</h3><ol><li><p>IP：通过IP地址粒度来进⾏权限控制，如”ip:192.168.0.110”表示权限控制针对该IP地址， 同时IP模式可以⽀持按照⽹段⽅式进⾏配置，如 “ip:192.168.0.1/24” 表示针对 <code>192.168.0.*</code> 这个⽹段进⾏权限控制。</p></li><li><p>Digest：是最常⽤的权限控制模式，要更符合我们对权限控制的认识，其使 ⽤”username:password”形式的权限标识来进⾏权限配置，便于区分不同应⽤来进⾏权限控制。当我们通过“username:password”形式配置了权限标识后，Zookeeper会先后对其进⾏SHA-1加密 和BASE64编码。</p></li><li><p>World：是⼀种最开放的权限控制模式，这种权限控制⽅式⼏乎没有任何作⽤，数据节点的访问权限 对所有⽤户开放，即所有⽤户都可以在不进⾏任何权限校验的情况下操作ZooKeeper上的数据。 另外，World模式也可以看作是⼀种特殊的Digest模式，它只有⼀个权限标识，即“ <code>world:anyone</code> ”。</p></li><li><p>Super：顾名思义就是超级⽤户的意思，也是⼀种特殊的Digest模式。在Super模式下，超级 ⽤户可以对任意ZooKeeper上的数据节点进⾏任何操作。</p></li></ol><p><strong>授权对象：ID</strong></p><table><thead><tr><th>权限模 式</th><th>授权对象</th></tr></thead><tbody><tr><td>IP</td><td>通常是⼀个IP地址或IP段：例如：192.168.10.110 或192.168.10.1/24</td></tr><tr><td>Digest</td><td>⾃定义，通常是username:BASE64(SHA-1(username:password))例如： zm:sdfndsllndlksfn7c=</td></tr><tr><td>Digest</td><td>只有⼀个ID ：anyone</td></tr><tr><td>Super</td><td>超级⽤户</td></tr></tbody></table><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>权限就是指那些通过权限检查后可以被允许执⾏的操作。在ZooKeeper中，所有对数据的操作权限分为 以下五⼤类：</p><ul><li>CREATE（C）：数据节点的创建权限，允许授权对象在该数据节点下创建⼦节点。</li><li>DELETE（D）：⼦节点的删除权限，允许授权对象删除该数据节点的⼦节点。</li><li>READ（R）：数据节点的读取权限，允 许授权对象访问该数据节点并读取其数据内容或⼦节点列表等。</li><li>WRITE（W）：数据节点的更新权 限，允许授权对象对该数据节点进⾏更新操作。</li><li>ADMIN（A）：数据节点的管理权限，允许授权对象 对该数据节点进⾏ ACL 相关的设置操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解Spring循环依赖</title>
      <link href="/2020/12/16/a622d780a1eb/"/>
      <url>/2020/12/16/a622d780a1eb/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h2><p>大家都知道spring的核心是一个实现了AOP的IOC容器，那么IOC容器对于bean的初始化，会遇到以下情况：当BeanA初始化时，它依赖的对象BeanB也需要执行初始化，如果BeanB里也依赖了BeanA,则又会开始执行BeanA的初始化，那么这样会无限循环，导致初始化异常如下所示。</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20201206003911766.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tzaXNu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Spring已经很好的解决了这个问题，这个解决方法就是三级缓存。</p><h2 id="什么是三级缓存？"><a href="#什么是三级缓存？" class="headerlink" title="什么是三级缓存？"></a>什么是三级缓存？</h2><p>我们以上图中A、B互相依赖为例，spring为了解决循环依赖问题，做了以下步骤：</p><ul><li><p>A通过反射创建的“初级bean”a放入到三级缓存中，再执行a的属性填充，这时发现依赖B，开启B的初始化。</p></li><li><p>B通过反射生成的“初级bean”b放入到三级缓存中，再执行b的属性填充，这时发现依赖A，开启A的初始化。</p></li><li><p>从三级缓存中找到a，A不再创建新对象，把它移动到二级缓存中，返回a。</p></li><li><p>b拿到a的引用，设置到b对应的字段上，属性填充完成，将b从三级缓存暴露到一级缓存中，返回b。</p></li><li><p>a拿到b的引用，设置到a对应的字段上，属性填充完成，将a从二级缓存暴露到一级缓存中，返回a，A对应的实例Bean初始化完成。</p><p><strong>其简易时序图</strong>：</p></li></ul><p><img src="https://img.jacian.com/note/img/20201216234410.png" alt="在这里插入图片描述"></p><p><strong>逻辑图如下：</strong></p><p><img src="https://img.jacian.com/note/img/20201216234418.jpeg" alt="在这里插入图片描述"></p><p><strong>咱们再看看三级缓存的存储结构</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="comment">/** 一级缓存，初始化完成的SpringBean均放置其中 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="comment">/** 二级缓存，反射完成后，还未填充属性的初级对象但是其他对象查询过时从三级中移动到二级 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="comment">/** 三级缓存，反射完成后，还未填充属性的初级对象放置其中 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>为什么三级缓存earlySingletonObjects和二级缓存singletonFactories的初始容量16，而一级缓存容量为256呢？笔者认为因为二级、三级仅仅是在处理依赖时会使用到，这种多重循环依赖的情况在实际项目中应该是少数，所以不用使用太大的空间。而最终spring实例化完成的bean会放置在一级缓存中，所以默认容量会调大一些，毕竟spring有很多自身的bean也是放置在这里面的，比如systemEnvironment、systemProperties、messageSource、applicationEventMulticaster等。</p><h2 id="spring的源码阅读"><a href="#spring的源码阅读" class="headerlink" title="spring的源码阅读"></a>spring的源码阅读</h2><p>当单例对象不存在时，会通过org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)方法来获取单例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="comment">// 在一级缓存singletonObjects中拿到为空 </span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/** 省略状态检查部分代码 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 传进来的调用，lamda表达式使用</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">// *********重要*********：singletonFactory.getObject()执行完毕，标记此类已经初始化完成</span></span><br><span class="line"><span class="comment">// bean初始化完成，标记为新的单例对象</span></span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是新的单例对象，暴露到一级缓存中</span></span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the given singleton object to the singleton cache of this factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To be called for eager registration of singletons.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> singletonObject the singleton object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// 加入到一级缓存，从二级和三级缓存中移除;</span></span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的singletonFactory.getObject() 无疑是执行创建的关键代码：</p><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到Bd</span></span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line"><span class="comment">// 获得类信息</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查该bean是否有重载方法</span></span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="comment">// 尝试获取代理对象;</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 进入，真真正正创建bean</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看doCreateBean方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 创建 Bean 实例，仅仅调用构造方法，但是尚未设置属性</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 暴露到三级缓存中</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化bean实例</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bean属性填充</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 调用初始化方法，应用BeanPostProcessor后置处理器</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 调用一次getSingleton(beanName, false)方法-&gt;&quot; + beanName)，只从一级、二级缓存中拿，传入false不需要从三级添加到二级缓存;</span></span><br><span class="line">            <span class="comment">// 核心逻辑是：如果提前暴露到了二级，则返回二级缓存中的对象引用，此时可能获取得到的是原对象的代理对象。因为AOP动态代理时，会将对象提升二级缓存，本文不再详述此问题</span></span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line"><span class="comment">/** 省略部分代码,检查依赖对象是否均创建完成 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化完成后一些注册操作</span></span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从doCreateBean方法可以看出：先调用构造方法，生成初级bean，然后暴露到三级缓存，然后执行属性填充，最表标记bean初始化完成，如果二级缓存有，则替换引用，最后完成注册并返回对象。</p><p>那么这个填充属性方法populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) 又做了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line"></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较多，核心思想就是获取这个bean里的所有依赖bean，然后调用applyPropertyValues方法去创建对应的依赖bean，并设置到对应的属性上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a deep copy, resolving any references for values.</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;&gt;(original.size());</span><br><span class="line"><span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line"><span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                String propertyName = pv.getName();</span><br><span class="line">                Object originalValue = pv.getValue();</span><br><span class="line">                <span class="comment">// *** 将依赖的属性目标，转化为初始化完成后的bean</span></span><br><span class="line">                Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">                Object convertedValue = resolvedValue;</span><br><span class="line">                <span class="comment">/** 省略部分代码 */</span></span><br><span class="line">                pv.setConvertedValue(convertedValue);</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">                <span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 省略部分代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valueResolver.resolveValueIfNecessary方法经过一些的方法，最终调用beanFactory.getBean，这个方法会回到开始进行新一轮的创建bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveInnerBean</span><span class="params">(Object argName, String innerBeanName, BeanDefinition innerBd)</span> </span>&#123;</span><br><span class="line">    String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">    <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory.registerDependentBean(dependsOnBean, actualInnerBeanName);</span><br><span class="line">            <span class="comment">// 初始化bean</span></span><br><span class="line">            <span class="keyword">this</span>.beanFactory.getBean(dependsOnBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allowEarlyReference传入true，对于新的bean，已经在三级缓存中存在，会将三级缓存转移到二级缓存，并返回bean，不用真正的去创建一个bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> needWarn = <span class="keyword">true</span>;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;当前bean已注册，从一级earlySingletonObjects中拿不到-&gt;&quot;</span> + beanName + <span class="string">&quot;：&quot;</span> + singletonObject);</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;当前bean已注册，从二级缓存earlySingletonObjects中拿不到-&gt;&quot;</span> + beanName + <span class="string">&quot;：&quot;</span> + singletonObject);</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">needWarn = <span class="keyword">false</span>;</span><br><span class="line">logger.warn(<span class="string">&quot;当前bean已注册，从三级singletonFactories中拿到，并移动到二级缓存earlySingletonObjects-&gt;&quot;</span> + beanName + <span class="string">&quot;  ： &quot;</span> + singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needWarn) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;从三级缓存中查询，调用DefaultSingletonBeanRegistry.getSingleton(beanName, allowEarlyReference)-&gt;得到&quot;</span> + beanName + <span class="string">&quot;:&quot;</span> + singletonObject + <span class="string">&quot;   ,allowEarlyReference：&quot;</span> + allowEarlyReference);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以第三步的Bean B属性填充方法此时完成，Bean B被加载到一级缓存中。由此回溯，Bean A的属性填充完成，Bean A被加载到一级缓存中。可结合本文最开始给出的时序图进行参考。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="为什么要用三级缓存而不是二级"><a href="#为什么要用三级缓存而不是二级" class="headerlink" title="为什么要用三级缓存而不是二级?"></a>为什么要用三级缓存而不是二级?</h3><p>我们可以从三级缓存的值类型看出，一、二级的值均为Spring Bean对象的引用，三级对象则为ObjectFactory的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="comment">/** 一级缓存，初始化完成的SpringBean均放置其中 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="comment">/** 二级缓存，反射完成后，还未填充属性的初级对象但是其他对象查询过时从三级中移动到二级 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="comment">/** 三级缓存，反射完成后，还未填充属性的初级对象放置其中 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><h4 id="为什么要有ObjectFactory类型的第三级缓存？"><a href="#为什么要有ObjectFactory类型的第三级缓存？" class="headerlink" title="为什么要有ObjectFactory类型的第三级缓存？"></a>为什么要有ObjectFactory类型的第三级缓存？</h4><p>将对象从三级缓存singletonFactories中移动到二级缓存时，会执行ObjectFactory的getBean方法，再调用到getEarlyBeanReference方法，最终遍历该Bean对应的所有SmartInstantiationAwareBeanPostProcessor进行执行；熟悉spring的朋友们肯定知道，SmartInstantiationAwareBeanPostProcessor是Spring Aop动态代理相关属性处理器。执行后获得一个新的bean，该bean是原bean代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新生成一个Factory对象，并设置其getBean方法为getEarlyBeanReference</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line"><span class="comment">// 等价于以下代码</span></span><br><span class="line"><span class="comment">/* addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public Object getObject() throws BeansException &#123;</span></span><br><span class="line"><span class="comment">return getEarlyBeanReference(beanName, mbd, bean);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;); */</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="comment">// getEarlyBeanReference方法：将会遍历其所有的SmartInstantiationAwareBeanPostProcessor（智能化属性处理器，然后进行执行）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，三级缓存 存在的目的就是增强对象，当需要使用spring的aop功能时返回代理对象，如果咱们永远用不到代理对象，三级缓存理论上可以不用。</p><h4 id="既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？"><a href="#既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？" class="headerlink" title="既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？"></a>既然三级缓存为了获取代理对象，只保留一三级缓存、第二级缓存可以不要吗？</h4><p>理论上可以，只需要两级缓存就可以解决循环依赖的问题，但在处理循环依赖的过程，一级缓存中将可能同时存在完整Spring Bean A 和 半成品Spring Bean B。三级对象getObject之后直接放置到二级，最后再刷到一级，二级到一级这个过程中并无额外的处理。</p><p>那么为什么spring要使用三级呢？笔者认为一是为了规范各级缓存职责单一原则，不让一级缓存中出现完整的bean和半成品bean；二是为了避免半成品bean被其他线程获取后进行调用，降低实现的难度。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC容器加载流程</title>
      <link href="/2020/12/16/c8a9c8065586/"/>
      <url>/2020/12/16/c8a9c8065586/</url>
      
        <content type="html"><![CDATA[<p>Spring容器的<code>AbstractApplicationContext#refresh()</code>【容器刷新】源码解析；本文只记录大体步骤， 细节部分自行阅读源码；</p><p><code>AbstractApplicationContext#refresh()</code>是IOC容器加载的主要流程，源代码如下</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 对象锁加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">         刷新前的预处理</span></span><br><span class="line"><span class="comment">         表示在真正做refresh操作之前需要准备做的事情：</span></span><br><span class="line"><span class="comment">          设置Spring容器的启动时间，</span></span><br><span class="line"><span class="comment">          开启活跃状态，撤销关闭状态</span></span><br><span class="line"><span class="comment">          验证环境信息里一些必须存在的属性等</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">         获取BeanFactory；默认实现是DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">                加载BeanDefition 并注册到 BeanDefitionRegistry</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">        BeanFactory的预准备工作（BeanFactory进行一些设置，比如context的类加载器等）</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">          BeanFactory准备工作完成后进行的后置处理工作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">          实例化实现了BeanFactoryPostProcessor接口的Bean，并调用接口方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">          注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Initialize message source for this context.</span></span><br><span class="line"><span class="comment">          初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        initMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">          初始化事件派发器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">          子类重写这个方法，在容器刷新的时候可以自定义逻辑；如创建Tomcat，Jetty等WEB服务器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        onRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">          注册应用的监听器。就是注册实现了ApplicationListener接口的监听器bean</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registerListeners();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">          初始化所有剩下的非懒加载的单例bean</span></span><br><span class="line"><span class="comment">          初始化创建非懒加载方式的单例Bean实例（未设置属性）</span></span><br><span class="line"><span class="comment">                    填充属性</span></span><br><span class="line"><span class="comment">                    初始化方法调用（比如调用afterPropertiesSet方法、init-method方法）</span></span><br><span class="line"><span class="comment">                    调用BeanPostProcessor（后置处理器）对实例bean进行后置处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">          完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，并且发布事件（ContextRefreshedEvent）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">          logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">        destroyBeans();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">        cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">        <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">        resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="逐步剖析"><a href="#逐步剖析" class="headerlink" title="逐步剖析"></a>逐步剖析</h1><h2 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh();"></a>prepareRefresh();</h2><p>刷新前的预处理，在这里主要完成对Spring的启动时间进行记录、对系统变量的属性合法性进行校验、初始化容器事件列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="comment">// 启动日期startupDate和活动标志active</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性设置，默认实现为空</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性合法性校验</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件存储容器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 重置事件存储容器</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储容器中早期事件的容器，在多播器可用时进行发布</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory();"></a>obtainFreshBeanFactory();</h2><p>初始化BeanFactory；这一步主要完成了BeanFactory的创建以及获取；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  refreshBeanFactory();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否已有bean factory</span></span><br><span class="line">  <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">    <span class="comment">// 销毁 beans</span></span><br><span class="line">    destroyBeans();</span><br><span class="line">    <span class="comment">// 关闭 bean factory</span></span><br><span class="line">    closeBeanFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化 DefaultListableBeanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    <span class="comment">// 设置序列化id</span></span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    <span class="comment">// 自定义bean工厂的一些属性（是否覆盖、是否允许循环依赖）</span></span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 解析XML配置文件，加载应用中的BeanDefinitions</span></span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">      <span class="comment">// 赋值当前bean facotry</span></span><br><span class="line">      <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在源码中可以获得以下三个重要信息：</p><ol><li><p>调用<code>refreshBeanFactory()</code>方法创建了BeanFactory，它的默认实现是<code>DefaultListableBeanFactory()</code></p></li><li><p>调用了<code>loadBeanDefinitions()</code>方法，完成了配置文件的解析，并封装成了<code>BeanDefinitions</code>对象存储到<code>BeanFactory</code>中；</p></li><li><p><code>getBeanFactory();</code>获取创建好的<code>BeanFactory</code>并返回</p></li></ol><h2 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory);"></a>prepareBeanFactory(beanFactory);</h2><p>BeanFactory的预准备工作，对BeanFactory进行一些默认设置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 上下文以及类加载器设置</span></span><br><span class="line">  beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">  beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">  beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置BeanFactory的上下文回调</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// 设置忽略的自动装配接口，如：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware等。</span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册可以解析的自动装配，可以直接在其它组件中自动注入，如：BeanFactory、ResourceLoaderAware、ApplicationEventPublisher、ApplicationContext。</span></span><br><span class="line">  beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">  beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加BeanPostProcessor——ApplicationListenerDetector</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加常用系统组件</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory的一些必要配置，不赘述。</p><h2 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory);"></a>postProcessBeanFactory(beanFactory);</h2><p>BeanFactory准备工作完成后进行的后置处理工作，Spring预留的切入点，子类通过重写这个方法，在BeanFactory创建并预准备完成后做进一步的操作。</p><h2 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);"></a>invokeBeanFactoryPostProcessors(beanFactory);</h2><p>执行<code>BeanFactoryPostProcessor</code>，<code>BeanFactoryPostProcessor</code>是<code>BeanFactory</code>的后置处理器，执行时机是<code>BeanFactory</code>标准初始化之后执行的，涉及接口：<code>BeanFactoryPostProcessor</code>、<code>BeanDefinitionRegistryPostProcessor</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 执行后置处理器（内部代码太长，不贴了，自行看），获取到所有的BeanFactoryPostProcessor </span></span><br><span class="line">  <span class="comment">// 排序后依次执行（排序方式按照：实现PriorityOrdered、实现Ordered接口、未实现优先级接口）</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">  <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这部分主要就是执行容器中<code>BeanFactoryPostProcessor</code> 的子类，对其子类注入<code>BeanFactory</code>，拆分一下执行流程大概分为以下四步：</p><ol><li><p>获取所有<code>BeanDefinitionRegistryPostProcessor</code></p></li><li><p>按照优先级进行排序，并按照优先级顺序执行<code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(registry);</code>，优先级顺序按照：实现<code>PriorityOrdered</code>、实现<code>Ordered</code>接口、未实现优先级接口</p></li><li><p>获取所有<code>BeanFactoryPostProcessor</code></p></li><li><p>按照优先级进行排序，并按照先后顺序执行<code>BeanFactoryPostProcessor#postProcessBeanFactory(beanFactory);</code>，优先级顺序按照：实现<code>PriorityOrdered</code>、实现<code>Ordered</code>接口、未实现优先级接口</p></li></ol><h2 id="registerBeanPostProcessors-beanFactory"><a href="#registerBeanPostProcessors-beanFactory" class="headerlink" title="registerBeanPostProcessors(beanFactory);"></a>registerBeanPostProcessors(beanFactory);</h2><p>注册<code>BeanPostProcessor</code>，<code>BeanPostProcessor</code>是Bean的后置处理器，用于拦截Bean 的创建过程，以下为内置的一些<code>BeanPostProcessor</code>：</p><blockquote><p><code>BeanPostProcessor DestructionAwareBeanPostProcessor InstantiationAwareBeanPostProcessor SmartInstantiationAwareBeanPostProcessor MergedBeanDefinitionPostProcessor</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取所有类型为 BeanPostProcessor 的BeanName</span></span><br><span class="line"> String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">  <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">  <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按照实现PriorityOrdered接口，Ordered接口和未实现优先级接口的顺序排序BeanPostProcessor</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先注册实现PriorityOrdered接口的后置处理器</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后注册实现 Ordered 接口的后置处理器</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后注册没有实现优先级接口的后置处理器</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后注册 MergedBeanDefinitionPostProcessor</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后在BeanPostProcessor的链尾再加入ApplicationListenerDetector</span></span><br><span class="line">  <span class="comment">// ApplicationListenerDetector作用功能是用于检测容器中的ApplicationLisenter，将其注册到上下文中</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上边代码比较长，其实做的事并没有这么复杂，主要就是对容器中后置处理器的排序，然后遍历注册的过程：</p><ol><li><p>获取所有<code>BeanPostProcessor</code>，不同接口类型的<code>BeanPostProcessor</code>，执行时机不同；【后置处理器都可以通过<code>PriorityOrdered</code>、<code>Ordered</code>指定优先级】</p></li><li><p>按照优先级进行排序，并按照先后顺序注册（<code>beanFactory#addBeanPostProcessor(postProcessor);</code>），优先级顺序：实现<code>PriorityOrdered</code>、实现<code>Ordered</code>接口、未实现优先级接口</p></li><li><p>最后注册<code>MergedBeanDefinitionPostProcessor</code>类型的后置处理器</p></li><li><p>最终注册负责扫描发现监听器子类的处理器<code>ApplicationListenerDetector</code>，在Bean创建完成后，检查是不是<code>ApplicationListener</code>类型，如果是就注册到容器中</p></li></ol><h2 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource();"></a>initMessageSource();</h2><p>初始化<code>MessageSource</code>组件（国际化、消息绑定、消息解析）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="comment">// MESSAGE_SOURCE_BEAN_NAME = &quot;messageSource&quot;，尝试在BeanFactory中获取ID为messageSource</span></span><br><span class="line">  <span class="comment">// 并且类型为MessageSource的Bean，如果有直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">    <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">      HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">      <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">        <span class="comment">// registered already.</span></span><br><span class="line">        hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果没有就直接赋值类型为DelegatingMessageSource的实例</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">    DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">    dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">    <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一步可以看出，如果我们需要使用国际化组件，只需要把<code>MessageSource</code>注册到容器中，获取国际化配置文件时，可以注入<code>MessageSource</code>组件进行使用：</p><ol><li><p>尝试在BeanFactory中获取id为<code>messageSource</code>且类型为<code>MessageSource</code>的组件</p></li><li><p>如果有就拿过来直接赋值；如果没有就自己创建一个<code>DelegatingMessageSource</code>；</p></li></ol><h2 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster();"></a>initApplicationEventMulticaster();</h2><p>初始化事件派发器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">  <span class="comment">// APPLICATION_EVENT_MULTICASTER_BEAN_NAME = &quot;applicationEventMulticaster&quot;</span></span><br><span class="line">  <span class="comment">// 尝试在容器中获取ID为applicationEventMulticaster并且类型为ApplicationEventMulticaster的Bean</span></span><br><span class="line">  <span class="comment">// 如果有直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">        beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有，那么构建一个SimpleApplicationEventMulticaster实例注册到容器中</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">    beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">          <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步和国际化组件的初始化流程类型，可以我们自身指定它的实现，如果不指定也没关系，因为Spring会有自身默认的实现</p><ol><li><p>尝试在BeanFactory中获取id为<code>applicationEventMulticaster</code>且类型为<code>ApplicationEventMulticaster</code>的组件；如果有则直接赋值到<code>applicationEventMulticaster</code></p></li><li><p>如果未找到<code>applicationEventMulticaster</code>组件，则会自动创建一个<code>SimpleApplicationEventMulticaster</code>的事件派发器，并将其添加到添加到容器中</p></li></ol><h2 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh();"></a>onRefresh();</h2><p>容器初始化期间执行的操作，子类重写这个方法，在容器刷新的时候可以自定义逻辑；如创建Tomcat，Jetty等WEB服务器</p><h2 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners();"></a>registerListeners();</h2><p>将所有事件监听器注册到容器中，也就是注册实现了<code>ApplicationListener</code>的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取预先存放的事件监听器</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取容器中所有类型为ApplicationListener 的Bean，注册到容器中</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 派发之前产生的事件</span></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下来其实也就是以下三个步骤：</p><ol><li><p>拿到容器中所有<code>ApplicationListener</code></p></li><li><p>将每个事件监听器添加到事件派发器中</p></li><li><p>派发之前产生的事件</p></li></ol><h2 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory);"></a>finishBeanFactoryInitialization(beanFactory);</h2><p>初始化所有剩下的单实例Bean，其中调用的<code>beanFactory.preInstantiateSingletons();</code>方法用于实现初始化其余单实例Bean的逻辑</p><ol><li><p>获取容器中所有的Bean，依次进行初始化和创建对象<code>RootBeanDefinition</code></p></li><li><p>依次获取Bean的定义信息</p></li><li><p>判断Bean：不是抽象的 &amp;&amp; 是单实例的 &amp;&amp; 不是懒加载的</p></li><li><p>判断是否是FactoryBean：是否是实现了FactoryBean接口。如果是则调用<code>getObject();</code>获取对象；</p></li><li><p>如果不是FactoryBean，利用<code>getBean(beanName);</code>创建对象</p></li><li><p>先获取缓存中保存的单实例Bean，如果能获取到说明之前已经创建过（所有创建的Bean都会被缓存起来）<code>Map singletonObjects = new ConcurrentHashMap(256);</code></p></li><li><p>如果缓存中获取不到Bean，开始创建Bean流程</p></li><li><p>标记当前Bean已经被创建【<code>markBeanAsCreated(beanName);</code>】</p></li><li><p>获取Bean定义信息【<code>final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</code>】</p></li><li><p>【获取当前Bean依赖的其它Bean（<code>String[] dependsOn = mbd.getDependsOn();</code>）。如果有，按照<code>getBean()</code>方式，把依赖的Bean先创建出来】</p></li><li><p>启动单实例Bean创建流程（<code>createBean(beanName, mbd, args);</code>）</p></li><li><p><code>resolveBeforeInstantiation(beanName, mbdToUse);</code>让<code>BeanPostProcessor</code>先拦截返回代理对象；如果是<code>InstantiationAwareBeanPostProcessor</code>类型，则执行<code>postProcessBeforeInstantiation</code>方法，如果有返回值，再触发<code>postProcessAfterInitialization</code>方法</p></li><li><p>如果前边的<code>InstantiationAwareBeanPostProcessor</code>没有返回代理对象，则执行3，如果返回了代理对象则直接返回Bean</p></li><li><p>执行<code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code>创建Bean</p></li><li><p>【创建Bean实例】<code>createBeanInstance(beanName, mbd, args);</code>，利用工厂方法或对象构造器创建Bean实例</p></li><li><p><code>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</code>，调用<code>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition</code>方法</p></li><li><p>【Bean属性赋值】<code>populateBean(beanName, mbd, instanceWrapper);</code></p></li><li><p>执行<code>InstantiationAwareBeanPostProcessor</code>后置处理器的<code>postProcessAfterInstantiation</code>方法</p></li><li><p>执行<code>InstantiationAwareBeanPostProcessor</code>后置处理器的<code>postProcessPropertyValues</code>方法</p></li><li><p><code>applyPropertyValues(beanName, mbd, bw, pvs);</code>应用Bean的属性值，为属性利用getset方法等进行赋值</p></li><li><p>【Bean初始化】<code>initializeBean(beanName, exposedObject, mbd);</code></p></li><li><p>【执行Aware】<code>invokeAwareMethods(beanName, bean);</code>执行xxxAwaer接口方法；如：<code>BeanNameAware</code>、<code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code></p></li><li><p>【执行后置处理器初始化之前的方法】<code>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</code> ，执行<code>BeanPostProcessor#postProcessBeforeInitialization</code>方法</p></li><li><p>【执行Bean初始化方法】<code>invokeInitMethods(beanName, wrappedBean, mbd);</code></p></li><li><p>判断是不是实现了<code>InitializingBean</code>接口，如果是执行该接口规定的初始化方法</p></li><li><p>判断是不是自定义了初始化方法</p></li><li><p>【执行初后置处理器初始化之后方法】<code>applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</code>，执行<code>BeanPostProcessor#postProcessAfterInitialization</code>方法</p></li><li><p>【注册Bean销毁方法】<code>registerDisposableBeanIfNecessary(beanName, bean, mbd);</code></p></li><li><p>将创建的Bean存入缓存：<code>singletonObjects</code>，IOC就是Map，很多的Map保存了单实例Bean、环境信息等。。。</p></li><li><p>所有Bean都利用<code>getBean()</code>创建完成之后，检查所有的Bean是否实现了<code>SmartInitializingSingleton</code>接口，如果是就执行<code>afterSingletonsInstantiated</code>方法</p></li></ol><h2 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh();"></a>finishRefresh();</h2><p>完成BeanFactory的初始化创建工作，IOC容器创建完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 清空上下文资源缓存</span></span><br><span class="line">  clearResourceCaches();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化生命周期相关后置处理</span></span><br><span class="line">  initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到声明周期处理器，回调容器刷新完成方法</span></span><br><span class="line">  getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布容器刷新完成事件</span></span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要就是完成一些收尾工作：</p><ol><li><p>初始化生命周期相关后置处理器；我们可以写一个<code>LifecycleProcessor</code>的实现类，可以在<code>BeanFactory</code>刷新完成和关闭的时候进行一次自定义操作。</p></li><li><p>拿到生命周期处理器（<code>LifecycleProcessor</code>），回调容器刷新完成方法</p></li><li><p>发布容器刷新完成事件</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>Spring容器启动时，会保存所有注册进来的Bean定义信息；xml、注解方式</p></li><li><p>Spring容器会在合适的时机创建这些注册好的Bean，使用这个Bean的时候，利用<code>getBean()</code>创建Bean，创建完成以后保存在容器中；方法<code>finishBeanFactoryInitialization(beanFactory);</code>统一创建剩下的单实例Bean；</p></li><li><p>后置处理器：每一个Bean注册完成后，都会使用各种后置处理器进行处理，来增强Bean的功能；<code>AutowireAnnotationBeanPostProcessor</code>【处理自动注入】、<code>AnnotationAwareAspectJProxyCreator</code>【AOP功能】、<code>AsyncAnnotationBeanPostProcessor</code>【异步处理接口】</p></li><li><p>事件驱动模型：<code>ApplicationListener</code>【事件监听】、ApplicationEventMulticaster【事件派发】</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 生命周期</title>
      <link href="/2020/11/19/3440e471cbb9/"/>
      <url>/2020/11/19/3440e471cbb9/</url>
      
        <content type="html"><![CDATA[<ol><li>实例化<code>Bean</code></li><li>设置<code>Bean</code>属性值</li><li>判断是否实现<code>BeanNameAware</code>，如果实现调用其setBeanName方法</li><li>判断是否实现<code>BeanFactoryAware</code>，如果实现调用其<code>setBeanFactory</code>方法<span id="more"></span></li><li>判断是否实现<code>ApplicationContextAware</code>，如果实现调用其<code>setApplicationContext</code>方法</li><li>调用<code>BeanPostProcessor</code>的预初始化方法</li><li>判断是否标注<code>@PostConstruct</code>注解，如果有则执行</li><li>判断是否实现<code>InitializingBean</code>，如果实现调用其<code>afterPropertiesSet</code>方法</li><li>判断是否配置初始化方法（<code>init-method</code>）</li><li>调用<code>BeanPostProcessor</code>的后初始化方法</li><li>是否为<code>singleton</code><ol><li>singleton: 将Bean放入SpringIOC的缓存池中</li><li>prototype: 将Bean交给调用者，后续不进行管理（不参与后续步骤）</li></ol></li><li>执行<code>@PreDestory</code>标注的方法</li><li>调⽤<code>DisposableBean的destory</code>⽅法</li><li>调⽤属性配置的销毁⽅法（<code>destory-method</code>）</li></ol><p><img src="https://img.jacian.com/note/img/20201119124023.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Framework 5.0.x 模块组成、体系结构、整体架构</title>
      <link href="/2020/09/03/8639a326bbf8/"/>
      <url>/2020/09/03/8639a326bbf8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.jacian.com/note/img/20200831175708.png"></p><h1 id="核心容器（Core-Containe）"><a href="#核心容器（Core-Containe）" class="headerlink" title="核心容器（Core Containe）"></a>核心容器（Core Containe）</h1><p>核心容器提供了Spring框架的基本功能，是其它模块建立的基础，有 <code>spring-core</code>、<code>spring-beans</code>、<code>spring-context</code>、<code>spring-context-support</code>和<code>spring-expression</code>（Expression Language、SpEL）组成。<code>spring-beans</code>和<code>spring-core</code>是spring框架的核心模块。</p><span id="more"></span><h2 id="spring-core"><a href="#spring-core" class="headerlink" title="spring-core"></a>spring-core</h2><p>提供了框架的基本组成部分，包括<code>控制翻转(Inversion of Control, IOC)</code>和<code>依赖注入(Dependency Injection, DI)</code>功能。</p><h2 id="spring-beans"><a href="#spring-beans" class="headerlink" title="spring-beans"></a>spring-beans</h2><p>提供了<code>BeanFactory</code>，<code>BeanFactory</code>接口是<code>spring</code>框架中的核心接口，它是<code>工厂模式</code>的经典实现。<code>BeanFactory</code>使用<code>控制翻转</code>对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。但<code>BeanFactory</code>容器实例化后并不会自动创建实例化<code>Bean</code>，只有当<code>Bean</code>被使用的时候<code>BeanFactory</code>容器才会对该<code>Bean</code>进行实例化与依赖关系的装配。</p><h2 id="spring-context"><a href="#spring-context" class="headerlink" title="spring-context"></a>spring-context</h2><p><code>spring-context</code>模块构架与<code>spring-core</code>和<code>spring-beans</code>模块之上，提供了一个框架式的对象访问方式，是访问定义和配置的任意对象的媒介。它扩展了<code>BeanFactory</code>，为其增加了<code>Bean</code>生命周期控制、框架事件体系以及资源加载透明化等功能。</p><p><code>ApplicationContext</code>是该模块的核心接口，它是<code>BeanFactory</code>的子类，与<code>BeanFactory</code>不同的是<code>ApplicationContext</code>容器实例化后会自动对所有的单实例<code>Bean</code>进行实例化与依赖关系的装配，使之处于待用状态。</p><h2 id="spring-context-support"><a href="#spring-context-support" class="headerlink" title="spring-context-support"></a>spring-context-support</h2><p>用于将常见的第三方库集成到<code>spring</code>应用程序上下文中。该模块提供了高速缓存、任务调度、邮件访问等支持。</p><h2 id="spring-expression"><a href="#spring-expression" class="headerlink" title="spring-expression"></a>spring-expression</h2><p>该模块是对<code>JSP2.1</code>规范中规定的统一表达式语言<code>EL</code>的扩展模块，它提供了强大的表达式语言去支持运行时查询和操作运行中的对象，该语言支持设置和获取属性值、属性分配、方法调用、访问数组、集合和索引器的内容、逻辑和算术运算、变量命名以及从Spring的IOC容器中以名称检索对象。它还支持列表投影、选择以及常用的列表聚合。</p><p>它的语法类似于传统的<code>EL</code>，但提供了额外的功能。最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 <code>spring</code> 产品的需求而设计，  他可以非常方便地同 <code>spring IOC</code> 进行交互。</p><h1 id="AOP-和设备支持（AOP）"><a href="#AOP-和设备支持（AOP）" class="headerlink" title="AOP 和设备支持（AOP）"></a>AOP 和设备支持（AOP）</h1><p>由<code>spring-aop</code>、<code>spring-aspects</code>和 <code>spring-instrument</code> 3个模块组成。</p><h2 id="spring-aop"><a href="#spring-aop" class="headerlink" title="spring-aop"></a>spring-aop</h2><p><code>spring-aop</code> 是spring的另一个核心模块，提供了一个符合AOP要求的面相切面的编程实现。作为继<code>OOP</code>之后，对程序员影响最大的编程思想之一，<code>AOP</code>极大的开拓了人们对于编程的思路。</p><p>在<code>spring</code>中，以<code>JDK动态代理</code>的技术为基础，设计出了一系列的<code>AOP</code>横切实现，比如：<code>前置通知</code>、<code>返回通知</code>和<code>异常通知</code>等。同时使用 <code>Pointcut</code> 接口匹配切入点，可以使用现有的切入点设计横切面；也可以扩展相关方法根据需求进行切入，将代码按照功能进行分离，以便干净的解耦。</p><h2 id="spring-aspects"><a href="#spring-aspects" class="headerlink" title="spring-aspects"></a>spring-aspects</h2><p>提供了与<code>AspectJ</code>的集成功能，主要是为<code>AOP</code>提供了多种实现方法。</p><h2 id="spring-instrument"><a href="#spring-instrument" class="headerlink" title="spring-instrument"></a>spring-instrument</h2><p>该模块是<code>spring-aop</code>的一个支援模块，提供了类植入(Instrumentation)支持和类加载器的实现。主要作用于JVM启动时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现<code>AOP</code>的功能。</p><h1 id="数据访问与集成（Data-Access-Integration）"><a href="#数据访问与集成（Data-Access-Integration）" class="headerlink" title="数据访问与集成（Data Access/Integration）"></a>数据访问与集成（Data Access/Integration）</h1><p>由<code>spring-jdbc</code>、<code>spring-orm</code>、<code>spring-oxm</code>、<code>spring-jms</code>和<code>spring-tx</code>组成。</p><h2 id="spring-jdbc"><a href="#spring-jdbc" class="headerlink" title="spring-jdbc"></a>spring-jdbc</h2><p><code>spring-jdbc</code>模块是<code>spring</code>提供的<code>JDBC</code>抽象层，消除了繁琐的编码以及数据库厂商特有的错误代码解析。用于简化<code>JDBC</code>，主要提供<code>JDBC</code>的模板方法、关系数据库对象化方式、事务管理来简化<code>JDBC</code>编程，主要实现类有<code>JdbcTemplate</code>、<code>SimpleJdbcTemplate</code>以及<code>NamedParameterJdbcTemplate</code>。</p><h2 id="spring-orm"><a href="#spring-orm" class="headerlink" title="spring-orm"></a>spring-orm</h2><p><code>spring-orm</code>模块是<code>ORM</code>的支持模块，主要集成<code>Hibernate</code>、<code>Java Persistence API(JPA)</code>和<code>Java Data Object(JDO)</code>用于资源管理、数据访问对象（DAO）的实现和事务策略。</p><h2 id="spring-oxm"><a href="#spring-oxm" class="headerlink" title="spring-oxm"></a>spring-oxm</h2><p><code>spring-oxm</code>模块主要提供一个抽象层支撑OXM(Object-to-XML-Mapping)，例如：<code>JAXB</code>、<code>Castor</code>、<code>XMLBeans</code>、<code>JiBX</code>和<code>XStream</code>等。</p><h2 id="spring-jms"><a href="#spring-jms" class="headerlink" title="spring-jms"></a>spring-jms</h2><p><code>spring-jms</code>模块（Java Message Service）为Java消息传递服务，能够发送和接收信息，自Spring Framework 4.1 以后，它还提供了对<code>spring-messaging</code>模块的继承。</p><h2 id="spring-tx"><a href="#spring-tx" class="headerlink" title="spring-tx"></a>spring-tx</h2><p><code>spring-tx</code>模块是<code>spring-jdbc</code>事务控制实现模块，支持用于实现所有接口和所有<code>POJO</code>(普通Java对象)类的编程和声明式事务的管理。</p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><p>由<code>spring-websocket</code>、<code>spring-webmvc</code>、<code>spring-web</code>和<code>spring-webflux</code>组成</p><h2 id="spring-web"><a href="#spring-web" class="headerlink" title="spring-web"></a>spring-web</h2><p><code>spring-web</code>模块为<code>spring</code>提供了最基础的<code>web</code>支持，主要建立在核心容器之上，通过<code>Servlet</code>或者<code>Listeners</code>来初始化IOC容器以及Web应用上下文，自动装载<code>WebApplicationContext</code>，也包含一些与<code>web</code>相关的支持，如：<code>Struts</code>集成类、文件上传支持的类、<code>FIlter</code>类和大量辅助工具类。</p><h2 id="spring-webmvc"><a href="#spring-webmvc" class="headerlink" title="spring-webmvc"></a>spring-webmvc</h2><p>也称<code>web-servlet</code>模块，包含用于<code>Web</code>应用程序的<code>Spring MVC</code>和<code>REST Web Service</code>实现。Spring MVC框架提供了领域模型代码和<code>Web</code>表单之间的清晰分离，并与<code>Spring Framework</code>的所有其他功能集成。</p><h2 id="spring-websocket"><a href="#spring-websocket" class="headerlink" title="spring-websocket"></a>spring-websocket</h2><p><code>Spring4.0</code>以后新增的模块，实现双工异步通讯协议，实现了<code>WebSocket</code>和<code>SocketJS</code>，提供<code>Socket</code>通信和<code>Web</code>端的推送功能。</p><h2 id="spring-webflux"><a href="#spring-webflux" class="headerlink" title="spring-webflux"></a>spring-webflux</h2><p>是一个新的非堵塞函数式<code>Reactive Web</code>框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。</p><h1 id="消息（Messaging）"><a href="#消息（Messaging）" class="headerlink" title="消息（Messaging）"></a>消息（Messaging）</h1><h2 id="spring-messaging"><a href="#spring-messaging" class="headerlink" title="spring-messaging"></a>spring-messaging</h2><p><code>spring-messaging </code>是从 <code>Spring4.0</code> 开始新加入的一个模块，主要职责是为 <code>Spring</code> 框架集成一些基础的报文传送应用。</p><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="spring-test"><a href="#spring-test" class="headerlink" title="spring-test"></a>spring-test</h2><p><code>spring-test</code>模块主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。</p><h1 id="spring-各模块依赖关系"><a href="#spring-各模块依赖关系" class="headerlink" title="spring 各模块依赖关系"></a>spring 各模块依赖关系</h1><p><img src="https://img.jacian.com/note/img/20200902100038.png"></p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/lj1314ailj/article/details/80118372">https://blog.csdn.net/lj1314ailj/article/details/80118372</a></p><p><a href="https://blog.csdn.net/ThinkWon/article/details/102810819">https://blog.csdn.net/ThinkWon/article/details/102810819</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 IoC？什么是 DI？它们之间是什么关系？</title>
      <link href="/2020/05/19/3463bd4622d4/"/>
      <url>/2020/05/19/3463bd4622d4/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是控制反转（IOC）"><a href="#什么是控制反转（IOC）" class="headerlink" title="什么是控制反转（IOC）"></a>什么是控制反转（IOC）</h2><p>Ioc—Inversion of Control，即“控制反转”，它是一种设计思想，并不是什么技术；在 Java 中，IOC 意味着将我们设计好的对象交给容器控制，而不是传统的需要时在内部构造直接控制；</p><span id="more"></span><h4 id="谁控制谁？控制了什么？"><a href="#谁控制谁？控制了什么？" class="headerlink" title="谁控制谁？控制了什么？"></a>谁控制谁？控制了什么？</h4><ul><li> <strong>谁控制了谁：</strong> IoC 控制了对象；</li><li> <strong>控制了什么：</strong> 主要控制了外部资源的获取，不仅限于对象，包括文件等资源；</li></ul><h3 id="什么为正转？什么为反转？"><a href="#什么为正转？什么为反转？" class="headerlink" title="什么为正转？什么为反转？"></a>什么为正转？什么为反转？</h3><ul><li><strong>正转：</strong>在我们需要某个对象的时候，需要自己主动的去构建对象以及其所依赖的对象；</li><li><strong>反转：</strong>在我们需要某个对象的时候，只需要在 IoC 容器中获取所需对象，无需关心创建过程以及其中的依赖对象；全盘由 IoC 容器帮我们创建对象以及注入其所依赖的对象，在这里我们把对象的控制权反转给了 IoC 容器，所以称为反转；</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>在现实生活中，当我们要用到一样东西的时候，第一反应是去找到这样东西，当我们想吃红烧肉的时候，如果没有饭店的支持，我们需要准备：肉、油、白砂糖、佐料等等一系列东西，然后自己去做，在这个过程中，所有的东西都是自己创造的这个过程称为正转；</p><p>然而到了今天，生活变好了加上互联网的兴起，当我们想吃红烧肉的时候，第一反应是去外卖平台描述出我们的需求，通过提供联系方式和送货地址，最后下订单，过一会儿就会有人给我们把红烧肉送过来，在这个过程中，我们并没有主动的去创造红烧肉，红烧肉是外卖平台上的商家创造的，但也完全达到了我们的需求，这个过程称为反转。</p><h2 id="什么是依赖注入（DI）"><a href="#什么是依赖注入（DI）" class="headerlink" title="什么是依赖注入（DI）"></a>什么是依赖注入（DI）</h2><p>DI-Dependency Injection，即”依赖注入”，就是由容器动态的将某个依赖注入到组件中。通过依赖注入机制，我们只需要简单的配置，无需任何代码就可以指定目标所需要的资源，从而完成自身的业务逻辑；我们无需关心具体的资源来自何处，提升了系统灵活性和可扩展性。<br><a name="oUXjU"></a></p><h2 id="IOC和DI的关系"><a href="#IOC和DI的关系" class="headerlink" title="IOC和DI的关系"></a>IOC和DI的关系</h2><p>DI 可以看作是 IoC 的一种实现方式，IoC 是一种思想，而 DI 是一种设计模式，是一种实现 IoC 的模式。<br><a name="HgQHh"></a></p><h2 id="依赖注入的三种方式"><a href="#依赖注入的三种方式" class="headerlink" title="依赖注入的三种方式"></a>依赖注入的三种方式</h2><ol><li><strong>构造方法注入：</strong> 被注入的对象可以通过在其构造方法中声明参数列表，让 IoC 容器知道它需要依赖哪些对象</li><li><strong>setter 注入：</strong> 为其需要依赖的对象增加 setter 方法，可以通过 setter 方法将其依赖的对象注入到对象中</li><li><strong>接口注入：</strong> 对于接口注入来说，如果被注入对象想要 IoC 容器为其注入依赖对象，就必须实现某个接口，这个接口提供了一个方法，用来为其注入依赖对象。但是从注入方式的使用来说，接口注入是现在不提倡的一种方式，基本处于”退役”状态，因为它强制被注入实现对象不必要的依赖。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么StringBuilder是线程不安全的？StringBuffer是线程安全的？</title>
      <link href="/2019/09/19/3a99a2ab384b/"/>
      <url>/2019/09/19/3a99a2ab384b/</url>
      
        <content type="html"><![CDATA[<p>面试中经常问到的一个问题：<code>StringBuilder</code>和<code>StringBuffer</code>的区别是什么？<br>我们非常自信的说出：<code>StringBuilder</code>是线程不安全的，<code>StirngBuffer</code>是线程安全的<br>面试官：<code>StringBuilder</code>不安全的点在哪儿？<br>这时候估计就哑巴了。。。</p><span id="more"></span><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><code>StringBuffer</code>和<code>StringBuilder</code>的实现内部是和<code>String</code>内部一样的，都是通过 <code>char[]</code>数组的方式；不同的是<code>String</code>的<code>char[]</code>数组是通过<code>final</code>关键字修饰的是不可变的，而<code>StringBuffer</code>和<code>StringBuilder</code>的<code>char[]</code>数组是可变的。</p><p>首先我们看下边这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                    stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">        System.out.println(stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直觉告诉我们输出结果应该是<code>10000000</code>，但是实际运行结果并非我们所想。</p><p><img src="https://img.jacian.com/FmucP95hkCgazmSiM1oq9-GoJ5cW" alt="执行结果"></p><p>从上图可以看到输出结果是<code>9970698</code>，并非是我们预期的<code>1000000</code>（什么情况？剩下的那些都被计算机吃了？），并且还抛出了一个异常<code>ArrayIndexOutOfBoundsException</code>（吃了我的东西还给我吐出来个异常）{非必现}</p><h1 id="为什么输出结果并非预期值？"><a href="#为什么输出结果并非预期值？" class="headerlink" title="为什么输出结果并非预期值？"></a>为什么输出结果并非预期值？</h1><p>我们先看一下<code>StringBuilder</code>的两个成员变量（这两个成员变量实际上是定义在<code>AbstractStringBuilder</code>里面的，<code>StringBuilder</code>和<code>StringBuffer</code>都继承了<code>AbstractStringBuilder</code>）</p><p><img src="https://img.jacian.com/Fgsq98wpAjFdyi-wYPDUPYZMQmzI" alt="AbstractStringBuilder.class"></p><p><code>StringBuilder</code>的<code>append</code>方法</p><p><img src="https://img.jacian.com/Fr1X_6JI1fakN8ogHMX-27yZQBJv" alt="StringBuilder.append(String str)"></p><p><code>StringBuilder</code>的<code>append</code>方法调用了父类的<code>append</code>方法</p><p><img src="https://img.jacian.com/Fowwe-2xu4GpspxBZSJikkON7Jy3" alt="AbstractStringBuilder.append(String str)"></p><p>我们直接看第七行代码，<code>count += len;</code> 不是一个原子操作，实际执行流程为</p><ul><li>首先加载<code>count</code>的值到寄存器</li><li>在寄存器中执行 <code>+1</code>操作</li><li>将结果写入内存</li></ul><p>假设我们<code>count</code>的值是<code>10</code>，<code>len</code>的值为<code>1</code>，两个线程同时执行到了第七行，拿到的值都是<code>10</code>，执行完加法运算后将结果赋值给<code>count</code>，所以两个线程最终得到的结果都是<code>11</code>，而不是<code>12</code>，这就是最终结果小于我们预期结果的原因。</p><h1 id="为什么会抛出ArrayIndexOutOfBoundsException异常？"><a href="#为什么会抛出ArrayIndexOutOfBoundsException异常？" class="headerlink" title="为什么会抛出ArrayIndexOutOfBoundsException异常？"></a>为什么会抛出ArrayIndexOutOfBoundsException异常？</h1><p>我们看回AbstractStringBuilder的追加（）方法源码的第五行，ensureCapacityInternal（）方法是检查StringBuilder的对象的原字符数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity（）方法对字符数组进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">void</span>  ensureCapacityInternal（<span class="keyword">int</span>  minimumCapacity）  &#123;</span><br><span class="line">         <span class="comment">//溢出意识代码</span></span><br><span class="line">    <span class="keyword">if</span>  （minimumCapacity  -  value .length&gt;  <span class="number">0</span>）</span><br><span class="line">        expandCapacity（minimumCapacity）; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的逻辑就是新一个新的字符数组，新的字符数组的容量是原来字符数组的两倍再加2，再通过System.arryCopy（）函数将原数组的内容复制到新数组，最后将指针指向新的字符数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  expandCapacity（<span class="keyword">int</span>  minimumCapacity）  &#123;</span><br><span class="line">     <span class="comment">//计算新的容量</span></span><br><span class="line">    <span class="keyword">int</span>  newCapacity =  value .length *  <span class="number">2</span>  +  <span class="number">2</span> ; </span><br><span class="line">    <span class="comment">//中间省略了一些检查逻辑</span></span><br><span class="line">     ...</span><br><span class="line">     value  = Arrays.copyOf（ value，newCapacity）; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrys.copyOf（）方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">char</span> []  copyOf（<span class="keyword">char</span> [] original，  <span class="keyword">int</span>  newLength）  &#123;</span><br><span class="line">     <span class="keyword">char</span> [] copy =  <span class="keyword">new</span>  <span class="keyword">char</span> [newLength]; </span><br><span class="line">    <span class="comment">//拷贝数组</span></span><br><span class="line">     System.arraycopy（original，  <span class="number">0</span>，copy，  <span class="number">0</span>，</span><br><span class="line">                         Math.min（original.length，newLength））; </span><br><span class="line">    返回  副本; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractStringBuilder的追加（）方法源码的第六行，是将字符串对象里面字符数组里面的内容拷贝到StringBuilder的对象的字符数组里面，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.getChars（<span class="number">0</span>，len，  value，count）;</span><br></pre></td></tr></table></figure><p>则GetChars（）方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span>  getChars（<span class="keyword">int</span>  srcBegin，  <span class="keyword">int</span>  srcEnd，  <span class="keyword">char</span>  dst []，  <span class="keyword">int</span>  dstBegin）  &#123;</span><br><span class="line">     <span class="comment">//中间省略了一些检查</span></span><br><span class="line">     ...   </span><br><span class="line">    System.arraycopy（ value，srcBegin，dst，dstBegin，srcEnd  -  srcBegin）; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝流程见下图<br><img src="https://img.jacian.com/FpDTeYULGYWcX-tiOBpZXzUZqJku" alt="StringBuilder.append()执行流程"></p><p>假设现在有两个线程同时执行了<code>StringBuilder</code>的<code>append()</code>方法，两个线程都执行完了第五行的<code>ensureCapacityInternal()</code>方法，此刻<code>count=5</code></p><p><img src="https://img.jacian.com/Frtri-MtOAmzqC2hh6OwmO2uv8_t" alt="StringBuilder.append()执行流程2"></p><p>这个时候<code>线程1</code>的<code>cpu</code>时间片用完了，<code>线程2</code>继续执行。线程2执行完整个<code>append()</code>方法后<code>count</code>变成<code>6</code>了。</p><p><img src="https://img.jacian.com/FpPE5_29h5bvuoJM0oI569QPGTo_" alt="StringBuilder.append()执行流程3"></p><p><code>线程1</code>继续执行第六行的<code>str.getChars()</code>方法的时候拿到的<code>count</code>值就是<code>6</code>了，执行<code>char[]</code>数组拷贝的时候就会抛出<code>ArrayIndexOutOfBoundsException</code>异常。</p><p>至此，<code>StringBuilder</code>为什么不安全已经分析完了。如果我们将测试代码的<code>StringBuilder</code>对象换成<code>StringBuffer</code>对象会输出什么呢？</p><p><img src="https://img.jacian.com/Fi-evX7qlA5yXUKX6TWtEqiv7PqI" alt="StringBuffer输出结果"></p><p>结果肯定是会输出 <code>1000000</code>，至于<code>StringBuffer</code>是通过什么手段实现线程安全的呢？看下源代码就明白了了。。。<br><img src="https://img.jacian.com/FlnMovQ1PXpI825EK9F8XP37VbUc" alt="StringBuffer.append()"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实践-远程调用Shell脚本并获取输出信息</title>
      <link href="/2019/09/09/deaaa1036195/"/>
      <url>/2019/09/09/deaaa1036195/</url>
      
        <content type="html"><![CDATA[<h1 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.ethz.ganymed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ganymed-ssh2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>262<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="2、Api说明"><a href="#2、Api说明" class="headerlink" title="2、Api说明"></a>2、Api说明</h1><ol><li>首先构造一个连接器，传入一个需要登陆的ip地址；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">new</span> Connection(ipAddr);</span><br></pre></td></tr></table></figure><ol start="2"><li>模拟登陆目的服务器，传入用户名和密码；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isAuthenticated = conn.authenticateWithPassword(userName, passWord);</span><br></pre></td></tr></table></figure><p>它会返回一个布尔值，true 代表成功登陆目的服务器，否则登陆失败。</p><ol start="3"><li>打开一个session，执行你需要的linux 脚本命令；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session session = conn.openSession();</span><br><span class="line">session.execCommand(“ifconfig”);</span><br></pre></td></tr></table></figure><ol start="4"><li>接收目标服务器上的控制台返回结果，读取br中的内容；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream stdout = <span class="keyword">new</span> StreamGobbler(session.getStdout());</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(stdout));</span><br></pre></td></tr></table></figure><ol start="5"><li>得到脚本运行成功与否的标志 ：0－成功 非0－失败</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(“ExitCode: ” + session.getExitStatus());</span><br></pre></td></tr></table></figure><ol start="6"><li>关闭session和connection</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><blockquote><p>Tips：</p><ol><li>通过第二部认证成功后当前目录就位于/home/username/目录之下，你可以指定脚本文件所在的绝对路径，或者通过cd导航到脚本文件所在的目录，然后传递执行脚本所需要的参数，完成脚本调用执行。</li><li>执行脚本以后，可以获取脚本执行的结果文本，需要对这些文本进行正确编码后返回给客户端，避免乱码产生。</li><li>如果你需要执行多个linux控制台脚本，比如第一个脚本的返回结果是第二个脚本的入参，你必须打开多个Session,也就是多次调用<br>Session sess = conn.openSession();,使用完毕记得关闭就可以了。</li></ol></blockquote><h1 id="3-实例：工具类"><a href="#3-实例：工具类" class="headerlink" title="3. 实例：工具类"></a>3. 实例：工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSHTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line">    <span class="keyword">private</span> String ipAddr;</span><br><span class="line">    <span class="keyword">private</span> Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SSHTool</span><span class="params">(String ipAddr, String userName, String password, Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ipAddr = ipAddr;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">if</span> (charset != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.charset = charset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录远程Linux主机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否登录成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        conn = <span class="keyword">new</span> Connection(ipAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连接</span></span><br><span class="line">            conn.connect();</span><br><span class="line">            <span class="comment">// 认证</span></span><br><span class="line">            <span class="keyword">return</span> conn.authenticateWithPassword(userName, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行Shell脚本或命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmds 命令行序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 脚本输出结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">exec</span><span class="params">(String cmds)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.login()) &#123;</span><br><span class="line">                <span class="comment">// 打开一个会话</span></span><br><span class="line">                Session session = conn.openSession();</span><br><span class="line">                session.execCommand(cmds);</span><br><span class="line">                in = session.getStdout();</span><br><span class="line">                result = <span class="keyword">this</span>.processStdout(in, <span class="keyword">this</span>.charset);</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != in) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析流获取字符串信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in      输入流对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charset 字符集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 脚本输出结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">processStdout</span><span class="params">(InputStream in, Charset charset)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//        OutputStream os = new FileOutputStream(&quot;./data.txt&quot;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//                os.write(buf, 0, c);</span></span><br><span class="line">                sb.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SSHTool tool = <span class="keyword">new</span> SSHTool(<span class="string">&quot;192.168.100.40&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        StringBuilder exec = tool.exec(<span class="string">&quot;bash /root/test12345.sh&quot;</span>);</span><br><span class="line">        System.out.println(exec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、测试脚本"><a href="#4、测试脚本" class="headerlink" title="4、测试脚本"></a>4、测试脚本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello&quot;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong><br><img src="https://img.jacian.com/FkVcWO0iG3G_KEa_1w_LFkxTop4p" alt="输出结果"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈关于SQL优化的思路</title>
      <link href="/2019/09/05/ec6e62d7dc9c/"/>
      <url>/2019/09/05/ec6e62d7dc9c/</url>
      
        <content type="html"><![CDATA[<h1 id="零、为什么要优化"><a href="#零、为什么要优化" class="headerlink" title="零、为什么要优化"></a>零、为什么要优化</h1><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><span id="more"></span><h1 id="一、观察"><a href="#一、观察" class="headerlink" title="一、观察"></a>一、观察</h1><p>MySQL优化≠SQL语句优化，理解这一点非常重要，虽然大部分时候我们都在调优SQL语句。</p><p>然而，MySQL的优化却是始于观察，而且有时候观察几分钟，几小时就能得出结论的，可能要观察一天以上。</p><p>这么做的目的很明显，就是为了帮助我们定位问题所在。<br>比如：MySQL的负载会在固定的某个时间节点突然暴涨，或者一请求某几个页面就产生了较为明显的延迟，甚至影响了随后的各个请求等。</p><p>观察的手段有多种多样，阿里云有强大的<code>RDS</code>控制台，也可以自建一套监控平台，最次的就是临时跑个<code>shell</code>脚本，收集<code>MySQL</code>运行状况。<br>观察的指标也不尽相同，最知名的 <code>show status</code> 命令列出的指标就能不下<code>200</code>个，所以观察也要有所取舍。<br>经常受人关注的指标有当前连接数以及最大连接数，当前运行的线程数，慢查询数量等。</p><h1 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h1><p>将观察的结果做进一步分析，也就形成了不同的解决思路。</p><p>可能是某个时间节点缓存失效，导致MySQL的负载激增，可以设法将缓存失效的时间节点尽可能均匀的分摊在一天24小时中，或者找个访问量较少的时段刷新缓存。</p><p>可能是SQL语句存在潜在问题，在某些情况下会有性能问题，可以用 <code>show full processlist</code> 定位是哪个库，也可以开启慢查询，直接定位到有问题的SQL语句，使用<code>explain</code>分析语句执行计划。可能加个索引能解决问题，也有可能join太多表，需要拆分查询，也有可能单表体量过大，要拆表了。</p><p>可能是机器本身性能问题，所谓“巧妇难为无米之炊”，这个时候要考虑扩容了。</p><h1 id="三、解决"><a href="#三、解决" class="headerlink" title="三、解决"></a>三、解决</h1><p>在分析阶段已经提及了大部分解决手段了，最后总结一下：</p><p>1、引入缓存，当然，这是一把双刃剑，要想用的恰如其分，还是需要一定的功力。缓存也分两方面的，一方面是MySQL的内部缓存机制，MySQL提供了多种缓存参数的配置，比如查询的结果集缓存，结果集排序的缓存，可根据实际情况进行调整。另一方面是MySQL之外的缓存，比如Redis+MySQL的架构，开启了Hibernate（Mybatis）的缓存功能。缓存的引入无非是想减轻MySQL的查询负担，但是必须在性能稳定性与数据时效性之间取得平衡。</p><p>2、SQL语句有性能问题，这种情况时有发生，通常是上线之前未能做一个完整的基准测试，而只是简单的功能性测试。当数据量积累到一定程度之后，SQL性能问题就集中爆发出来了。所以，在写完SQL之后，要养成<code>explain</code>的习惯，将潜在的性能问题扼杀在萌芽中。当然，我们也要避免“过度优化”，我们要预见得到一张表是读取次数多，还是更新次数多，数据量会不会爆发性增长，还是增长十分缓慢。当然，写SQL语句也要遵循一定的原则，比如什么时候用IN查询，什么时候用<code>EXISTS</code>谓词，在<code>JOIN</code>之前是不是可以精简一部分表数据，建立的索引能否正确派上用场……</p><p>3、必要的时候，可以对机器进行扩容，当然系统的整体架构也可以考虑进行优化，搭建MySQL集群，可靠性和可用性都能得到大幅提升。</p><h1 id="四、补充：SQL范式"><a href="#四、补充：SQL范式" class="headerlink" title="四、补充：SQL范式"></a>四、补充：SQL范式</h1><p><strong>1NF</strong></p><blockquote><p>每一个分量必须是不可分的数据项。</p></blockquote><p>特点：</p><ul><li>有主键，且主键不能为空。</li><li>字段不能再分。</li></ul><p><strong>2NF</strong></p><blockquote><p>在范式一的基础上，且每一个非主属性完全函数依赖于码。</p></blockquote><p>特点：</p><ul><li>满足第一范式。</li><li>表中的每一个非主属性，必须完全依赖于本表码。</li><li>只有当一个表中，主码由两个或以上的属性组成的时候，才会出现不符合第二范式的情况。</li></ul><p><strong>3NF</strong></p><blockquote><p>在满足第二范式的基础上，且每一个非主属性既不部分依赖于码也不传递依赖于码。</p></blockquote><p>特点：</p><ul><li>满足第二范式。</li><li>非主属性不能传递依赖于码。</li></ul><p>** BCNF**</p><blockquote><p>在满足第三范式的基础上，且不允许主键的一部分被另一部分或其它部分决定。</p></blockquote><p>特点：</p><ul><li>满足第三范式。</li><li>所有非主属性对每一个码都是完全函数依赖。</li><li>所有的主属性对每一个不包含它的码，也是完全函数依赖。</li><li>没有任何属性完全函数依赖于飞码的任何一组属性。</li></ul><p><strong>以上是对MySQL优化的框架性思考。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建Zookeeper&amp;Kafka集群</title>
      <link href="/2019/08/27/d43887d6fa3d/"/>
      <url>/2019/08/27/d43887d6fa3d/</url>
      
        <content type="html"><![CDATA[<p><strong>前排提示：最新的<code>docker-compole.yml</code>请去github获取，<code>README</code>有相应的操作步骤。</strong><br>Github地址：<a href="https://github.com/JacianLiu/docker-compose">https://github.com/JacianLiu/docker-compose</a></p><blockquote><p><strong>最近在学习<code>Kafka</code>，准备测试集群状态的时候感觉无论是开三台虚拟机或者在一台虚拟机开辟三个不同的端口号都太麻烦了（嗯。。主要是懒）。</strong></p></blockquote><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><div class="note info"><p>一台可以上网且有CentOS7虚拟机的电脑</p></div>> 为什么使用虚拟机？因为使用的笔记本，所以每次连接网络IP都会改变，还要总是修改配置文件的，过于繁琐，不方便测试。（通过Docker虚拟网络的方式可以避免此问题，当时实验的时候没有了解到）# Docker 安装> 如果已经安装Docker请忽略此步骤<ol><li>Docker支持以下的CentOS版本：</li><li>CentOS 7 (64-bit)：要求系统为64位、系统内核版本为 3.10 以上。</li><li>CentOS 6.5（64-bit）或更高的版本：要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</li><li>CentOS 仅发行版本中的内核支持 Docker。</li></ol><h2 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看上文的前提条件来验证你的CentOS 版本是否支持 Docker 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看内核版本</span><br><span class="line">$ uname -a</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装 Docker</span><br><span class="line">$ yum -y install docker</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#启动 Docker 后台服务</span><br><span class="line">$ service docker start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。</span><br><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h2><ol><li>使用 sudo 或 root 权限登录 Centos。</li><li>确保 yum 包更新到最新。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum update</span><br></pre></td></tr></table></figure></li><li>获取并执行 Docker 安装脚本。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line"># 执行这个脚本会添加 docker.repo 源并安装 Docker。</span><br><span class="line">$ sudo sh get-docker.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 验证 docker 是否安装成功并在容器中执行一个测试的镜像。</span><br><span class="line">$ sudo docker run hello-world</span><br><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>开始让我配置国内镜像源的时候我是拒绝的，但是使用之后发现那下载速度 <code>duang~</code> 的一下就上去了。所以强烈建议大家配置国内镜像源。<br>打开/创建 <code> /etc/docker/daemon.json</code> 文件，添加以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h1><div class=“note info”><p>Zookeeper镜像：zookeeper:3.4</p></div>## 镜像准备<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull zookeeper:3.4</span><br></pre></td></tr></table></figure>> 查找镜像可以去 https://hub.docker.com/docker pull images:TAG // 代表拉取 `TAG` 版本的 `image` 镜像<h2 id="建立独立Zookeeper容器"><a href="#建立独立Zookeeper容器" class="headerlink" title="建立独立Zookeeper容器"></a>建立独立Zookeeper容器</h2><p>我们首先用最简单的方式创建一个独立的<code>Zookeeper</code>节点，然后我们根据这个例子创建出其他的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name zookeeper -p 2181:2181 -d zookeeper:3.4</span><br></pre></td></tr></table></figure><p>默认的，容器内配置文件在， <code>/conf/zoo.cfg</code>，数据和日志目录默认在 <code>/data</code> 和 <code>/datalog</code>，需要的话可以将上述目录映射到宿主机。<br><strong>参数解释</strong></p><blockquote><ol><li>–name：指定容器名字</li><li>-p：为容器暴露出来的端口分配端口号</li><li>-d：在后台运行容器并打印容器ID</li></ol></blockquote><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>其它节点的<code>Zookeeper</code>容器创建方式与创建独立容器类似，需要注意的是，要分别指定节点的<code>id</code>和修改文件中多节点的配置，相应的创建命令如下：</p><h3 id="新建docker网络"><a href="#新建docker网络" class="headerlink" title="新建docker网络"></a>新建docker网络</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create zoo_kafka</span><br><span class="line">$ docker network ls</span><br></pre></td></tr></table></figure><h3 id="Zookeeper容器1"><a href="#Zookeeper容器1" class="headerlink" title="Zookeeper容器1"></a>Zookeeper容器1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">     --restart=always \</span><br><span class="line">     -v /opt/docker/zookeeper/zoo1/data:/data \</span><br><span class="line">     -v /opt/docker/zookeeper/zoo1/datalog:/datalog \</span><br><span class="line">     -e ZOO_MY_ID=1 \</span><br><span class="line">     -p 2181:2181 \</span><br><span class="line">     -e ZOO_SERVERS=&quot;server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888&quot; \</span><br><span class="line">     --name=zoo1 \</span><br><span class="line">     --net=viemall-zookeeper \</span><br><span class="line">     --privileged \</span><br><span class="line">     zookeeper:3.4</span><br></pre></td></tr></table></figure><h3 id="Zookeeper容器2"><a href="#Zookeeper容器2" class="headerlink" title="Zookeeper容器2"></a>Zookeeper容器2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">     --restart=always \</span><br><span class="line">     -v /opt/docker/zookeeper/zoo2/data:/data \</span><br><span class="line">     -v /opt/docker/zookeeper/zoo2/datalog:/datalog \</span><br><span class="line">     -e ZOO_MY_ID=2 \</span><br><span class="line">     -p 2182:2181 \</span><br><span class="line">     -e ZOO_SERVERS=&quot;server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888&quot; \</span><br><span class="line">     --name=zoo2 \</span><br><span class="line">     --net=viemall-zookeeper \</span><br><span class="line">     --privileged \</span><br><span class="line">     zookeeper:3.4</span><br></pre></td></tr></table></figure><h3 id="Zookeeper容器3"><a href="#Zookeeper容器3" class="headerlink" title="Zookeeper容器3"></a>Zookeeper容器3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">     --restart=always \</span><br><span class="line">     -v /opt/docker/zookeeper/zoo3/data:/data \</span><br><span class="line">     -v /opt/docker/zookeeper/zoo3/datalog:/datalog \</span><br><span class="line">     -e ZOO_MY_ID=3 \</span><br><span class="line">     -p 2183:2181 \</span><br><span class="line">     -e ZOO_SERVERS=&quot;server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888&quot; \</span><br><span class="line">     --name=zoo3 \</span><br><span class="line">     --net=viemall-zookeeper \</span><br><span class="line">     --privileged \</span><br><span class="line">     zookeeper:3.4</span><br></pre></td></tr></table></figure><blockquote><p>这种方式虽然也实现了我们想要的，但是步骤过于繁琐，而且维护起来麻烦（懒癌晚期），所以我们使用 <code>docker-compose</code> 的方式来实现。</p></blockquote><h2 id="docker-compose-搭建zookeeper集群"><a href="#docker-compose-搭建zookeeper集群" class="headerlink" title="docker-compose 搭建zookeeper集群"></a>docker-compose 搭建zookeeper集群</h2><h3 id="新建docker网络-1"><a href="#新建docker网络-1" class="headerlink" title="新建docker网络"></a>新建docker网络</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create --driver bridge --subnet 172.23.0.0/25 --gateway 172.23.0.1  zoo_kafka</span><br><span class="line">$ docker network ls</span><br></pre></td></tr></table></figure><h3 id="编写-docker-compose-yml-脚本"><a href="#编写-docker-compose-yml-脚本" class="headerlink" title="编写 docker-compose.yml 脚本"></a>编写 docker-compose.yml 脚本</h3><p><strong>使用方式：</strong></p><ol><li>安装 <code>docker-compose</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 获取脚本</span><br><span class="line">$ curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"># 赋予执行权限</span><br><span class="line">$chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li>任意目录下新建 <code>docker-compose.yml</code> 文件，复制以下内容</li><li>执行命令 <code>docker-compose up -d </code></li></ol><p><strong>命令对照</strong></p><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker-compose up</td><td>启动所有容器</td></tr><tr><td>docker-compose up -d</td><td>后台启动并运行所有容器</td></tr><tr><td>docker-compose up –no-recreate -d</td><td>不重新创建已经停止的容器</td></tr><tr><td>docker-compose up -d test2</td><td>只启动test2这个容器</td></tr><tr><td>docker-compose stop</td><td>停止容器</td></tr><tr><td>docker-compose start</td><td>启动容器</td></tr><tr><td>docker-compose down</td><td>停止并销毁容器</td></tr></tbody></table><p><code>docker-compose.yml</code>下载地址：<a href="https://github.com/JacianLiu/docker-compose/tree/master/zookeeper">https://github.com/JacianLiu/docker-compose/tree/master/zookeeper</a><br><strong><code>docker-compose.yml</code>详情</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4</span> <span class="comment"># 镜像名称</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 当发生错误时自动重启</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 挂载数据卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./zoo1/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./zoo1/datalog:/datalog</span> </span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span> <span class="comment"># 节点ID</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span> <span class="comment"># zookeeper端口号</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=zoo2:2888:3888</span> <span class="string">server.3=zoo3:2888:3888</span> <span class="comment"># zookeeper节点列表</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.23</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./zoo2/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./zoo2/datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=zoo2:2888:3888</span> <span class="string">server.3=zoo3:2888:3888</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.23</span><span class="number">.0</span><span class="number">.12</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./zoo3/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./zoo3/datalog:/datalog</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888</span> <span class="string">server.2=zoo2:2888:3888</span> <span class="string">server.3=zoo3:2888:3888</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.23</span><span class="number">.0</span><span class="number">.13</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">zoo_kafka</span></span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>从图中我们可以看出，有一个<code>Leader</code>，两个<code>Flower</code>，至此我们的<code>Zookeeper</code>集群就已经搭建好了<br><img src="https://img.jacian.com/1566900790498.png" alt="Zookeeper"></p><h1 id="Kafka集群搭建"><a href="#Kafka集群搭建" class="headerlink" title="Kafka集群搭建"></a>Kafka集群搭建</h1><p>有了上面的基础，再去搞<code>Kafka</code>集群还是问题吗？其实就是几个变量值不同而已。</p><p>有了上边的例子，就不费劲去搞单节点的<code>Kafka</code>了，直接使用<code>docker-compose</code>的方式，部署三个节点，其实方式大同小异，上边也说到，其实就是一些属性不同而已；这时候我们就不需要再去新建 Docker 网络了，直接使用前边搭建 <code>Zookeeper</code> 集群时创建的网络即可！</p><h2 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h2><blockquote><p>Kafka镜像：wurstmeister/kafka<br>Kafka-Manager镜像：sheepkiller/kafka-manager</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 不指定版本默认拉取最新版本的镜像</span><br><span class="line">docker pull wurstmeister/kafka</span><br><span class="line">docker pull sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure><h2 id="编写-docker-compose-yml-脚本-1"><a href="#编写-docker-compose-yml-脚本-1" class="headerlink" title="编写 docker-compose.yml 脚本"></a>编写 docker-compose.yml 脚本</h2><p><strong>使用方式：</strong></p><ol><li>安装 <code>docker-compose</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 获取脚本</span><br><span class="line">$ curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"># 赋予执行权限</span><br><span class="line">$chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li>任意目录下新建 <code>docker-compose.yml</code> 文件，复制以下内容</li><li>执行命令 <code>docker-compose up -d </code></li></ol><p><strong>命令对照</strong><br>|命令|解释|<br>|-|-|<br>|docker-compose up|启动所有容器|<br>|docker-compose up -d|后台启动并运行所有容器|<br>|docker-compose up –no-recreate -d|不重新创建已经停止的容器|<br>|docker-compose up -d test2|只启动test2这个容器|<br>|docker-compose stop|停止容器|<br>|docker-compose start|启动容器|<br>|docker-compose down|停止并销毁容器|</p><p><code>docker-compose.yml</code>下载地址：<a href="https://github.com/JacianLiu/docker-compose/tree/master/zookeeper">https://github.com/JacianLiu/docker-compose/tree/master/zookeeper</a><br><strong><code>docker-compose.yml</code>详细内容</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">broker1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">broker1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">broker1</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9091:9092&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://broker1:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://broker1:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="string">broker1</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zoo1:2181/kafka1,zoo2:2181/kafka1,zoo3:2181/kafka1</span></span><br><span class="line">      <span class="attr">JMX_PORT:</span> <span class="number">9988</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./broker1:/kafka/kafka\-logs\-broker1</span></span><br><span class="line">    <span class="attr">external_links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.23</span><span class="number">.0</span><span class="number">.14</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">broker2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">broker2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">broker2</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9092:9092&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://broker2:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://broker2:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="string">broker2</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zoo1:2181/kafka1,zoo2:2181/kafka1,zoo3:2181/kafka1</span></span><br><span class="line">      <span class="attr">JMX_PORT:</span> <span class="number">9988</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./broker2:/kafka/kafka\-logs\-broker2</span></span><br><span class="line">    <span class="attr">external_links:</span>  <span class="comment"># 连接本compose文件以外的container</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.23</span><span class="number">.0</span><span class="number">.15</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">broker3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">broker3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">broker3</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9093:9092&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://broker3:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://broker3:9092</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="string">broker3</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="number">9092</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zoo1:2181/kafka1,zoo2:2181/kafka1,zoo3:2181/kafka1</span></span><br><span class="line">      <span class="attr">JMX_PORT:</span> <span class="number">9988</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./broker3:/kafka/kafka\-logs\-broker3</span></span><br><span class="line">    <span class="attr">external_links:</span>  <span class="comment"># 连接本compose文件以外的container</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.23</span><span class="number">.0</span><span class="number">.16</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka-manager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sheepkiller/kafka-manager:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka-manager</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kafka-manager</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">    <span class="attr">links:</span>            <span class="comment"># 连接本compose文件创建的container</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">broker1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">broker2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">broker3</span></span><br><span class="line">    <span class="attr">external_links:</span>   <span class="comment"># 连接本compose文件以外的container</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zoo1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zoo2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZK_HOSTS:</span> <span class="string">zoo1:2181/kafka1,zoo2:2181/kafka1,zoo3:2181/kafka1</span></span><br><span class="line">      <span class="attr">KAFKA_BROKERS:</span> <span class="string">broker1:9092,broker2:9092,broker3:9092</span></span><br><span class="line">      <span class="attr">APPLICATION_SECRET:</span> <span class="string">letmein</span></span><br><span class="line">      <span class="attr">KM_ARGS:</span> <span class="string">-Djava.net.preferIPv4Stack=true</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.23</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span>   <span class="comment"># 使用已创建的网络</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">zoo_kafka</span></span><br></pre></td></tr></table></figure><h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><p>我们打开<code>kafka-manager</code>的管理页面，访问路径是，宿主机ip:9000；<br><img src="https://img.jacian.com/1566902368519.png" alt="Kafka-Manager"><br>如果所示，填写上<code>Zookeeper</code>集群的地址，划到最下边点击<code>save</code><br>点击刚刚添加的集群，可以看到，集群中有三个节点<br><img src="https://img.jacian.com/1566902527518.png" alt="Kafka-Cluster"></p><h1 id="搭建过程中遇到的问题"><a href="#搭建过程中遇到的问题" class="headerlink" title="搭建过程中遇到的问题"></a>搭建过程中遇到的问题</h1><ol><li>挂载数据卷无限重启，查看<code>log</code>提示：chown: changing ownership of ‘/var/lib/mysql/….‘: Permission denied<br>解决方式：<ul><li>在docker run中加入 –privileged=true  给容器加上特定权限</li><li>临时关闭selinux： setenforce 0</li><li>添加selinux规则，改变要挂载的目录的安全性文本</li></ul></li><li>kafka-manager报jmx相关错误，<br>解决方法：<ul><li>在每一个kafka节点加上环境变量  JMX_PORT=端口</li><li>加上之后发现连不上，又是网络连接的问题，于是又把每个jmx端口暴露出来，然后fire-wall放行， 解决问题。</li><li><code>KAFKA_ADVERTISED_HOST_NAME</code>这个最好设置宿主机的ip,宿主机以外的代码或者工具来连接，后面的端口也需要设置暴露的端口。 </li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] k.m.j.KafkaJMX$ - Failed to connect to service:jmx:rmi:<span class="comment">///jndi/rmi://9.11.8.48:-1/jmxrmi java.lang.IllegalArgumentException: requirement failed: No jmx port but jmx polling enabled!</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在容器中查看<code>topic</code>时报以下错误（不仅仅是topic的命令，好像所有的都会出错）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bin/kafka-topics.sh --list --zookeeper zoo1:2181/kafka1,zoo2:2181/kafka1,zoo3:2181/kafka1</span><br><span class="line"># 以下是错误</span><br><span class="line">Error: Exception thrown by the agent : java.rmi.server.ExportException: Port already in use: 7203; nested exception is:</span><br><span class="line">        java.net.BindException: Address already in use</span><br></pre></td></tr></table></figure>解决方法：<br> 在命令前加上<code>unset JMX_PORT;</code>指令，上边的命令改造为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unset JMX_PORT;bin/kafka-topics.sh --list --zookeeper zoo1:2181/kafka1,zoo2:2181/kafka1,zoo3:2181/kafka1</span><br></pre></td></tr></table></figure></li></ol><h1 id="附：Docker常用指令"><a href="#附：Docker常用指令" class="headerlink" title="附：Docker常用指令"></a>附：Docker常用指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有镜像</span><br><span class="line">docker images</span><br><span class="line"># 查看所有运行中的容器</span><br><span class="line">docker ps</span><br><span class="line"># 查看所有容器</span><br><span class="line">docker ps -a</span><br><span class="line"># 获取所有容器ip</span><br><span class="line">$ docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; $(docker ps -aq)</span><br><span class="line"># 查看容器内部日志</span><br><span class="line">$ docker logs -f &lt;容器ID&gt;</span><br><span class="line"># 进入容器内部</span><br><span class="line">$ docker exec -it &lt;容器ID&gt; /bin/basj</span><br><span class="line"># 创建容器 -d代表后台启动</span><br><span class="line">docker run --name &lt;容器名称&gt; -e &lt;参数&gt; -v &lt;挂载数据卷&gt; &lt;容器ID&gt;</span><br><span class="line"># 重启容器</span><br><span class="line">docker restart &lt;容器ID&gt;</span><br><span class="line"># 关闭容器</span><br><span class="line">docker stop &lt;容器id&gt;</span><br><span class="line"># 运行容器</span><br><span class="line">docker start &lt;容器id&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Kafka </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2019/08/25/6a1c6c833261/"/>
      <url>/2019/08/25/6a1c6c833261/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇问题"><a href="#开篇问题" class="headerlink" title="开篇问题"></a>开篇问题</h2><div class="note info"><p>问题：如何用链表来实现 LRU 缓存淘汰策略呢？</p></div>## 链表的作用<p>链表一个经典的应用场景就是<code>LRU</code>缓存淘汰算法；</p><p>缓存是一种提高数据读取性能的技术，在开发中有着非常广泛的应用，由于缓存的大小有限，当缓存被占满时，哪些数据应该被清理，哪些数据应该被保留？这就需要淘汰策略来决定，常见的淘汰策略有三种：先进先出策略FIFO（First In, First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。</p><p>打个比方：假如说你买了很多书籍，但有一天发现书太多了，太占空间，你要做个大扫除。那么这个时候你会选择扔掉哪些书籍？对应一下，其实就是我们上边说的三种策略；</p><span id="more"></span><h2 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h2><p>为了理解起来更容易，我们拿数组来做对比；</p><p>相比数组，链表是一种稍微复杂一点的数据结构。从底层的存储结构上来看：数组需要一块儿连续的内存空间，堆内存的要求比较高，如果我们申请一个100MB大小的数组，当内存中没有连续的、足够大的空间的时候，即便内存的剩余总可用空间大于100MB，仍然会申请失败；而链表恰恰相反，它并不需要一块儿连续的内存空间，它通过“指针”将一组零散的内存块串联起来，所以如果我们申请100MB大小的链表，如果没有100MB连续的内存空间，且内存的剩余总可用空间大于100MB，根本不会有问题；</p><p><img src="https://img.jacian.com/1566713304093.jpg" alt="数组和链表的内存分布图"></p><h2 id="常见的链表结构"><a href="#常见的链表结构" class="headerlink" title="常见的链表结构"></a>常见的链表结构</h2><p>链表的结构五花八门，今天重点来介绍下三种最常见的链表结构，分别是：单链表、双向链表和循环链表。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>刚刚提到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块成为链表的“节点”。为了将所有的节点穿起来，每个节点除了存储数据以外，还需要记录链上的下一个节点的地址，我们把这个记录下个节点地址的指针叫做后继节点 <code>next</code>；</p><p><img src="https://img.jacian.com/1566713562440.jpg" alt="单链表"></p><p>从图中我们发现，有两个节点是比较特殊的，分别是第一个节点和最后一个节点。我们称第一个节点为头结点，最后一个节点叫做尾节点。其中头结点用来记录链表的基地址，有了它我们就可以遍历得到整条链表；而为节点特殊的地方是：指针不是指向下一个节点，而是指向一个空地址 NULL，表示这是链表上的最后一个节点；</p><p><strong>链表的增删改查</strong></p><p>我们在进行数组的插入、删除操作的时候，为了保持内存数据的连续性，需要进行大量的数据搬移工作，所以时间复杂度为 O(n)；而在链表中插入或者删除一个数据我们并不需要为了保持内存的连续性而搬移节点，因为链表本身的存储空间也不是连续的，所以在链表中插入和删除一个数据是非常快的；</p><p><strong>插入数据：</strong>我们只需要将要插入位置的前一个数据单元的next指针指向插入数据的内存地址，插入数据的next指针指向下一个数据的内存地址；</p><p><strong>删除数据：</strong>将要删除数据的前一个数据单元的next指针指向要删除数据的下一个数据单元的内存地址，然后再删除数据；</p><p><img src="https://img.jacian.com/1566714229446.jpg" alt="链表的插入与删除"></p><p>但是，链表想要访问第k个元素时，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样根据首地址和下标，通过寻址公式就能计算出对应的内存空间，而是需要根据指针一个节点一个节点的依次遍历，直到找到相应的节点。</p><p>链表就好比是在学校站队一样，假如我们都只知道自己后面的人是谁，如果我们想知道第k个人是谁，我们就需要从第一个人开始，一个一个的往下数。所以，链表随机访问的性能没有数组好，需要O(n)的时间复杂度；</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong>循环链表</strong>其实就是一种特殊的单链表，它根单链表唯一的区别就在于尾节点，上文我们提到单链表的尾节点的next指针指向空地址，表示这是最后的节点了；而循环链表的尾节点指针指向的是链表的头结点，如下图，它就像一个环一样收尾项链，所以叫做<strong>循环链表</strong>。</p><p><img src="https://img.jacian.com/1566714696458.jpg" alt="循环链表"></p><blockquote><p>和单链表相比，循环链表的优点是从链尾到连头比较方便，当要处理的数据具有环形特点时，就特别适合使用循环链表。</p></blockquote><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单链表只有一个方向，节点只有一个后继指针next指向后面的节点。而双向链表支持两个方向，每个节点不仅有一个后继指针，还有一个前驱指针prev指向前面的节点。</p><p><img src="https://img.jacian.com/1566714925460.jpg" alt="双向链表"></p><p>从图中我们不难看出，双向链表需要额外的两个空间来存储后继节点和前驱节点的地址。所以存储同样多的数据，双向链表占用的空间要大于单向链表。虽然内存的占用增大了，但是可以支持双向遍历，这样使得双向链表的操作更加灵活。</p><p>双向链表相比单向链表：从结构上看，双向链表可以支持 O(1)时间复杂度下找到前驱节点，也使得双向链表在某些情况下的插入和删除等操作要比单链表更加的简单高效。</p><p>在上文中我们说单向链表的时候，提到单链表的增加和删除操作的时间复杂度也是 O(1) ，但这种结果偏于理论，接下来我们通过实际的例子来分析。</p><p><strong>删除操作</strong></p><p>在实际开发中，从链表中删除一个数据无外乎两种情况：</p><ol><li>删除节点中“值等于某个给定的值”的节点；</li><li>删除给定指针指向的节点；</li></ol><p>对于第一种情况，不管是单链表还是双链表，为了查找值等于给定值的节点，都需要从头节点开始一个一个依次遍历对比，知道找到值等于给定值的节点，然后在进行删除操作；</p><p>尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)，根据时间复杂度分析中的加法法则，删除值等于给定值的节点对应的链表操作的总时间复杂为O(n)。</p><p>对于第二种情况，我们已经找到了要删除的节点，但是删除某个节点 q ，需要知道其前驱节点，而单链表并不支持直接获取前驱节点，所以为了找到前驱节点，我们还是要从头节点开始遍历链表，直到找到 p-&gt;next=q，说明p是q的前驱节点；</p><p>但是对于双向链表来讲，这种情况就比较有优势。因为双向链表中的节点已经保存了前驱节点的指针，不需要像单链表那样遍历。所以针对第二种情况，单链表删除的操作需要O(n)的时间复杂度，而双向链表只要O(1)的时间复杂度。</p><p>同理，如果我们希望在链表的某个节点前面插入一个节点；双向链表比单链表有很大的优势。双向链表可以再O(1)的时间复杂度搞定，而单向链表需要O(n)的时间复杂度，可以参考上边删除操尝试自己分析一下；</p><blockquote><p><strong>用空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p></blockquote><h2 id="链表-amp-数组性能对比"><a href="#链表-amp-数组性能对比" class="headerlink" title="链表&amp;数组性能对比"></a>链表&amp;数组性能对比</h2><p>数组和链表的存储方式截然不同，正是因为内存存储方式的不同，它们插入、删除、随机访问操作的时间复杂度正好相反；</p><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>插入、删除</td><td>O(n)</td><td>O(1)</td></tr><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td></tr></tbody></table><p>不过在实际开发中要根据实际场景来选择具体的数据结构存储，不能仅仅通过时间复杂度来决定；</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读取数组中的数据，所以访问效率更高；而链表在内存中并不是连续的所以对CPU缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，已经声明就要占用整块连续的内存空间；如果声明数组过大，可能会导致内存不足，如果声明数组过小，可能会导致容量不够用，这是就需要在申请一个更大的内存空间，把原数组copy进去，非常耗时；链表本身没有大小的限制，天然支持动态扩容。虽然Java中的ArrayList也支持动态扩容，但是其本质就是当容量不足时去申请一个更大的空间去存储；</p><h2 id="解题开篇"><a href="#解题开篇" class="headerlink" title="解题开篇"></a>解题开篇</h2><p>好了，关于链表的知识我们就讲完了。我们现在回过头来看下开篇留给你的思考题。如何基于链表实现 LRU 缓存淘汰算法？</p><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：</li></ol><ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul><h2 id="如何判断一个字符串是否是回文字符串的问题？"><a href="#如何判断一个字符串是否是回文字符串的问题？" class="headerlink" title="如何判断一个字符串是否是回文字符串的问题？"></a>如何判断一个字符串是否是回文字符串的问题？</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>首先用一个快指针，一个慢指针来遍历链表。快指针每次走两步，慢指针每次走一步。等到快指针遍历完链表，慢指针就正好停留在链表的中央。 </li><li>将链表的后半部分进行反转。 </li><li>将链表的前半部分与后半部分逐个比对。若都相同，则为回文链表，否则不是。 链表遍历的时间复杂度大约为 n/2。反转的时间复杂度为n/2。逐个比对的复杂度为n/2，所以总体的时间复杂度为O(n).而其中用于暂存的节点只有两个。因此空间复杂度为O(1)。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">      ListNode next = slow.next;</span><br><span class="line">      slow.next = prev;</span><br><span class="line">      prev = slow;</span><br><span class="line">      slow = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (slow.val != prev.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次由于线程使用不当引发的血案</title>
      <link href="/2019/08/20/1e1cd313bc24/"/>
      <url>/2019/08/20/1e1cd313bc24/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近给第三方做了一个接口，接口的作用是接收数据对数据进行验证之后通过<code>kafka</code>推送到模型进行数据处理，最终通过<code>kafka</code>接收模型的数据，开始只做了一个异步的接口，由于对方业务原因需要一个同步的接口传输数据，但是每当运行一段时间之后程序就会进入假死状态，接口无法正常调用；</p><span id="more"></span><h3 id="同步接口"><a href="#同步接口" class="headerlink" title="同步接口"></a>同步接口</h3><p>同步接口的实现是使用阻塞Map，当对方发送请求时，对数据进行验证，然后推送到模型，等待结果返回之后将处理好的数据推送到对方接口，此时这次请求给调用方返回相应信息；</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>开始认为是由于用户量过大导致内存不足引发的程序假死，使用<code>JMeter</code>进行压力测试异步接口模拟10000个请求同时调用接口，程序如丝滑般运行，没有丝毫问题，所有请求都正常返回（这里由于在家里通过VPN连接的公司开发服务器，网络不稳定，所以就拿少量测试用例为例）；</p><p><img src="https://img.jacian.com/1566311401001.png"></p><p>然后开始怀疑是不是同步接口出了问题，刚开始模拟少量请求，因为当时是在开发环境进行测试，模型并没有放上去，所以没有返回信息，一直在等待模型的返回结果，也是没有问题的，这时候调用异步接口也没有任何问题；</p><blockquote><p><strong>思考：所有资源都是阻塞状态，因为没有处理结果，一直没有释放进程，当数据过大时会不会造成服务器资源耗尽，导致程序假死？</strong></p></blockquote><p><img src="https://img.jacian.com/1566311734998.png"></p><p>当再次加大同步接口的调用次数的时候，再去尝试请求异步接口，发现异步接口也没有了返回信息，这时遍确认了问题所在；</p><p>线程全部在阻塞状态，当太多资源没有释放掉时，服务器资源耗尽，导致程序无法正常运行；</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>找到问题之后就是要解决问题，去掉同步接口是不可能的，所以要给阻塞的线程设置一个超时时间，当长时间没有等到模型的处理数据时，主动放弃监听，释放掉占用的资源，从而保证服务器资源充足；</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>虽然问题解决了，但是模型的数据产出最长达10秒钟，当并发量过大时还是会出现这种问题，在不动模型的情况下如何解决这种问题？如何一直保证服务器资源充足？</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>阻塞Map的实现：<a href="https://songsong.iteye.com/blog/802881">https://songsong.iteye.com/blog/802881</a></p><p>压力测试简介和JMeter的简单实用：<a href="https://www.cnblogs.com/TankXiao/p/4059378.html">https://www.cnblogs.com/TankXiao/p/4059378.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2019/08/20/f4450572bd9e/"/>
      <url>/2019/08/20/f4450572bd9e/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>问题：为什么数组下标是从0开始，而不是从1开始；</p></div>### 什么是数组？<p>数组是一种<strong>线性表数据结构</strong>，它用一组<strong>连续的内存空间来存储一组相同类型的数据</strong>。</p><span id="more"></span><p><strong>线性表结构</strong>：数据排成一条线一样的结构，每个线性表上最多只有前和后两个方向，除数组外，链表、队列、栈也是线性结构。</p><p><img src="https://img.jacian.com/1566225023427.jpg"></p><p><strong>非线性结构</strong>：比如：二叉树、图、堆等，在非线性结构中，数据之间并不是简单的前后关系。</p><p><img src="https://img.jacian.com/1566225085700.jpg"></p><p><strong>连续的内存空间和相同类型的数据：</strong>正式因为这两个特性，才有了它的一大特性：“随机访问”；缺点：在数组中要进行删除或者插入操作需要进行大量的迁移工作，效率低下；</p><p><strong>关于数组的随机访问：</strong>例如一个长度为<code>10</code>的<code>int</code>类型的数组 <code>int a[] = new int[10];</code>在下图中，计算机给数组 <code>a[10]</code>分配了一块儿连续的内存空间 1000~1039；其中，内存的首地址 <code>base_address=1000</code></p><p><img src="https://img.jacian.com/1566225603216.jpg"></p><p>我们知道，计算机会给每一个内存单元分配一个地址，通过地址来访问到内存中存储的数据；当计算机需要随机访问数组中的元素时，会根据如下的公式找出该元素存储的内存地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>其中 <code>data_type_size</code>表示数据中每个元素的大小。在当前例子中存储的为 <code>int</code> 类型，所以 <code>data_type_size</code>的大小为 <code>4</code>。</p><div class="note success no-icon"><p>“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p></div>### 低效的插入和删除<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设数组<code>arr</code>的长度为<code>n</code>，现在我们要在数组<code>arr</code>的第<code>k</code>个位置插入一个元素，为了把 <code>k</code>这个位置腾出来给新的元素，那么我们需要把 <code>k~n</code>这部分元素都顺序往后移一位。</p><p>如果是插入到数组的末尾，那么我们就不需要对移动数据，这时候时间复杂度为<code>O(1)</code>。如果在数组的开头插入元素，那所有的数据都要往后移一位，这时候的时间复杂度为<code>O(n)</code>。那么平均复杂度则为<code>O(n)</code>。</p><p>如果我们插入的元素是有序的，那么我们就必须按照上边的操作依次将数组往后移动一位。但是如果数组中的元素没有任何规律，数组只是被当做一个存储数据的集合。在这种情况下，如果想要将某个数据插入到<code>k</code>这个位置，为了避免大量的数据迁移，最简单的方法就是，直接将第<code>k</code>位的元素放到最后，把要插入的元素直接放到<code>k</code>的位置。</p><p>例如：现有数组 <code>a[10]</code>存储了五个元素：<code>a、b、c、d、e</code>；我们现在要将元素<code>x</code>插入到第三个位置，我们只需要把<code>c</code>放到<code>a[5]</code>，将<code>a[2]</code>赋值为<code>x</code>即可；最终得到的数组中的元素为：<code>a、b、x、d、e、c</code>；利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 <code>O(1)</code>。</p><p><img src="https://img.jacian.com/1566226645699.jpg"></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>和插入操作类似，当我们要删除数组中的某个元素时，要对数据进行搬移操作，不然数据中间会出现空洞，内存就不连续了；</p><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 <code>O(1)</code>；如果删除开头的数据，则最坏情况时间复杂度为 <code>O(n)</code>；平均情况时间复杂度也为 <code>O(n)</code>。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p><p>例如：数组 <code>a[10]</code> 中存储了 <code>8</code> 个元素：<code>a，b，c，d，e，f，g，h</code>。现在，我们要依次删除 <code>a，b，c</code> 三个元素；为了避免 <code>d，e，f，g，h</code> 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p><img src="https://img.jacian.com/1566226907613.jpg"></p><blockquote><p> 这是 JVM 标记清除垃圾回收算法的核心思想</p></blockquote><h3 id="解题开篇"><a href="#解题开篇" class="headerlink" title="解题开篇"></a>解题开篇</h3><p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从 <code>0</code> 开始编号，而不是从 <code>1</code> 开始呢？</p><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是<code>“偏移（offset）”</code>。前面也讲到，如果用 a 来表示数组的首地址，<code>a[0]</code> 就是偏移为 <code>0</code> 的位置，也就是首地址，<code>a[k]</code> 就表示偏移 <code>k</code> 个 <code>data_type_size</code> 的位置，所以计算 <code>a[k]</code> 的内存地址只需要用这个公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * data_type_size</span><br></pre></td></tr></table></figure><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k - <span class="number">1</span>) * data_type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，我们不难发现，从 <code>1</code> 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><p><strong>思考：</strong></p><ol><li> JVM 的标记清除垃圾回收算法的核心理念。</li><li>前面我提到一维数组的内存寻址公式，思考、类比一下，二维数组的内存寻址公式是怎样的呢？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo&amp;GitHub从零搭建个人博客</title>
      <link href="/2019/08/19/ac69dda2d50f/"/>
      <url>/2019/08/19/ac69dda2d50f/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon"><p>现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。</p></div><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>下载&amp;安装node.js，默认会安装npm：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></li><li>下载&amp;安装git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li><li>下载安装hexo。方法：打开cmd 运行<code>npm install -g hexo</code></li></ul><h3 id="本地搭建hexo静态博客"><a href="#本地搭建hexo静态博客" class="headerlink" title="本地搭建hexo静态博客"></a>本地搭建hexo静态博客</h3><ul><li>新建一个文件夹，如<code>blog</code></li><li>进入该文件夹内，右击运行git，输入：<code>hexo init</code>（生成hexo模板）</li><li>生成完模板，运行<code>npm install</code>（目前貌似不用运行这一步）</li><li>最后运行：<code>hexo s</code> （运行程序，访问本地localhost:4000可以看到博客已经搭建成功）</li></ul><p><img src="https://img.jacian.com/1566207418011.png"></p><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml// 博客配置文件</span><br><span class="line">├── public// 静态文件存放目录</span><br><span class="line">│   ├── 2019</span><br><span class="line">│   ├── archives</span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   └── lib</span><br><span class="line">├── source</span><br><span class="line">│   └── _posts// 博文存放路径</span><br><span class="line">└── themes// 主题路径</span><br><span class="line">    ├── landscape</span><br><span class="line">    └── next</span><br></pre></td></tr></table></figure><h3 id="将博客与Github关联"><a href="#将博客与Github关联" class="headerlink" title="将博客与Github关联"></a>将博客与Github关联</h3><ul><li>在Github上创建名字为<code>XXX.github.io</code>的项目，<code>XXX</code>为自己的GitHub用户名。</li><li>打开本地的MyBlog文件夹项目内的<code>_config.yml</code>配置文件，将其中的type设置为git</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/XXX/XXX.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><ul><li>运行：<code>npm install hexo-deployer-git –save</code></li><li>运行：<code>hexo g</code>（本地生成静态文件）</li><li>运行：<code>hexo d</code>（将本地静态文件推送至Github）</li></ul><blockquote><p>此时打开 <a href="https://xxx.github.io/">https://XXX.github.io</a> ，即可看到效果</p></blockquote><div class="note warning"><p>这里注意把文中的 XXX 修改为自己的github用户名</p></div>### 更新文章<ul><li>在<code>blog</code>目录下执行：<code>hexo new “我的第一篇文章”</code>，会在source-&gt;_posts文件夹内生成一个.md文件。</li><li>编辑该文件（遵循Markdown规则）</li><li>修改起始字段<ul><li>title 文章的标题</li><li>date 创建日期 （文件的创建日期 ）</li><li>updated 修改日期 （ 文件的修改日期）</li><li>comments 是否开启评论 true</li><li>tags 标签</li><li>categories 分类</li><li>permalink url中的名字（文件名）</li></ul></li><li>编写正文内容（MakeDown）</li><li><code>hexo clean</code> 删除本地静态文件（public目录）</li><li><code>hexo g</code> 生成本地静态文件（public目录）</li><li><code>hexo deploy</code> 将本地静态文件推送至github（hexo d）</li></ul><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><blockquote><p>至此，我们的博客就已经搭建完了，发现两个问题，一是丑，二是使用GitHub默认域名不舒服。所以我们要修改一个好看的主题（默认的主题经过一番DIY也能达到不错的效果，这里就不多做演示）和使用自己的域名（可选），非必须，看个人喜好。</p></blockquote><p>目前安装的主题：<a href="https://github.com/theme-next/hexo-theme-next">Next</a></p><p>更多主题：<a href="https://github.com/hexojs/hexo/wiki/Themes">主题</a></p><p>主题配置文档：<a href="https://theme-next.iissnan.com/theme-settings.html">Next主题配置</a></p><h4 id="1、在博客的根目录下，也就是上文提到的blog文件夹中，执行clone主题"><a href="#1、在博客的根目录下，也就是上文提到的blog文件夹中，执行clone主题" class="headerlink" title="1、在博客的根目录下，也就是上文提到的blog文件夹中，执行clone主题"></a>1、在博客的根目录下，也就是上文提到的blog文件夹中，执行clone主题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h4 id="2、修改hexo配置文件"><a href="#2、修改hexo配置文件" class="headerlink" title="2、修改hexo配置文件"></a>2、修改hexo配置文件</h4><p>使用文本编辑器打开<code>blog</code>目录下的<code>_config.yml</code>文件，将 <code>themes</code> 对应的值进行修改，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><h4 id="3、重新生成静态文件"><a href="#3、重新生成静态文件" class="headerlink" title="3、重新生成静态文件"></a>3、重新生成静态文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>浏览器打开 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到效果。确认没问题执行 <code>hexo d</code> 命令更新到GitHub，稍等片刻重新打开  <a href="https://xxx.github.io/">https://XXX.github.io</a> 便可看到效果；</p><p><img src="https://img.jacian.com/1566208941026.png"></p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><ul><li><p>域名提供商设置</p><p>添加一条CNAME记录：</p><p>CNAME —&gt; XXX.github.io</p></li><li><p>博客添加CNAME文件</p><p>配置完域名解析后，进入博客目录，在<code>source</code>目录下新建<code>CNAME</code>文件，写入域名，如：jacian.com</p></li><li><p>运行：<code>hexo g</code></p></li><li><p>运行：<code>hexo d</code></p></li></ul><p><em>重新发布完，稍等片刻打开自己的域名即可看到效果。至此你的个人博客就已经搭建完毕了；当然，你还可以做一些DIY的设置，在这篇文章中就不一一列举了，可以参考文档或者其他大神的博客去进行一些自定义的设置。</em></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Netty-SocketIO的主动推送服务</title>
      <link href="/2019/07/13/db0f0b26d663/"/>
      <url>/2019/07/13/db0f0b26d663/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前端时间，公司开发了一款主动服务的机器人的程序，讲产生的消息通过服务端主动推送到客户端(H5、IOS、Android)，支持用户的个性化开关设置，用户可自由选择接受的消息类型；同时支持用户主动提问；在此记录下整个部署以及实现的大致思路；</p><blockquote><p>同时感谢我的Leader给予的帮助。</p></blockquote><span id="more"></span><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h4 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h4><ul><li>为了保持长连接有效，配置HTTP版本1.1；</li><li>配置<code>Upgrade</code>和<code>Connection</code>响应头信息；</li></ul><p>完整配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># enable WebSockets</span></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade $http_upgrade;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Socket配置"><a href="#Socket配置" class="headerlink" title="Socket配置"></a>Socket配置</h4><p>Socket配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(WebSocketConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wss.server.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wss.server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;redis.passwd&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisPasswd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;redis.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PubSubStore <span class="title">pubSubStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> socketIOServer().getConfiguration().getStoreFactory().pubSubStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">socketIOServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Config redissonConfig = <span class="keyword">new</span> Config();</span><br><span class="line">      <span class="comment">// 高版本需求 redis:// 前缀</span></span><br><span class="line">      redissonConfig.useSingleServer().setPassword(<span class="string">&quot;xxx&quot;</span>).setAddress(<span class="string">&quot;redis://xxx:xx&quot;</span>).setDatabase();</span><br><span class="line"></span><br><span class="line">        RedissonClient redisson = Redisson.create(redissonConfig);</span><br><span class="line">        RedissonStoreFactory redisStoreFactory = <span class="keyword">new</span> RedissonStoreFactory(redisson);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Configuration config = <span class="keyword">new</span> Configuration();</span><br><span class="line">        config.setHostname(host);</span><br><span class="line">        config.setPort(port);</span><br><span class="line">        config.setOrigin(origin);</span><br><span class="line">        config.setHttpCompression(<span class="keyword">false</span>);</span><br><span class="line">        config.setWebsocketCompression(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        config.setStoreFactory(redisStoreFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意如果开放跨域设置，需要设置为null而不是&quot;*&quot;</span></span><br><span class="line">        config.setOrigin(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 协议升级超时时间（毫秒），默认10000。HTTP握手升级为ws协议超时时间</span></span><br><span class="line">        config.setUpgradeTimeout(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// Ping消息间隔（毫秒），默认25000。客户端向服务器发送一条心跳消息间隔</span></span><br><span class="line">        config.setPingInterval(<span class="number">25000</span>);</span><br><span class="line">        <span class="comment">// Ping消息超时时间（毫秒），默认60000，这个时间间隔内没有接收到心跳消息就会发送超时事件</span></span><br><span class="line">        config.setPingTimeout(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 异常监听事件，必须覆写全部方法 */</span></span><br><span class="line">        config.setExceptionListener(<span class="keyword">new</span> ExceptionListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectException</span><span class="params">(Exception e, SocketIOClient client)</span> </span>&#123;</span><br><span class="line">                ResponseMessage error = ResponseMessage.error(-<span class="number">1</span>, <span class="string">&quot;连接异常！&quot;</span>);</span><br><span class="line">                client.sendEvent(<span class="string">&quot;exception&quot;</span>, JSON.toJSON(<span class="keyword">new</span> Response&lt;String&gt;(error, <span class="string">&quot;连接异常！&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnectException</span><span class="params">(Exception e, SocketIOClient client)</span> </span>&#123;</span><br><span class="line">                ResponseMessage error = ResponseMessage.error(-<span class="number">1</span>, <span class="string">&quot;断开异常！&quot;</span>);</span><br><span class="line">                client.sendEvent(<span class="string">&quot;exception&quot;</span>,JSON.toJSON(<span class="keyword">new</span> Response&lt;String&gt;(error, <span class="string">&quot;连接异常！&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventException</span><span class="params">(Exception e, List&lt;Object&gt; data, SocketIOClient client)</span> </span>&#123;</span><br><span class="line">                ResponseMessage error = ResponseMessage.error(-<span class="number">1</span>, <span class="string">&quot;服务器异常！&quot;</span>);</span><br><span class="line">                client.sendEvent(<span class="string">&quot;exception&quot;</span>,JSON.toJSON(<span class="keyword">new</span> Response&lt;String&gt;(error, <span class="string">&quot;连接异常！&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPingException</span><span class="params">(Exception e, SocketIOClient client)</span> </span>&#123;</span><br><span class="line">                ResponseMessage error = ResponseMessage.error(-<span class="number">1</span>, <span class="string">&quot;PING 超时异常！&quot;</span>);</span><br><span class="line">                client.sendEvent(<span class="string">&quot;exception&quot;</span>,JSON.toJSON(<span class="keyword">new</span> Response&lt;String&gt;(error, <span class="string">&quot;PING 超时异常！&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 类似于过滤器设置，此处不作处理</span></span><br><span class="line">       config.setAuthorizationListener(data -&gt; &#123;</span><br><span class="line"><span class="comment">//            // 可以使用如下代码获取用户密码信息</span></span><br><span class="line"><span class="comment">//            String appId = data.getSingleUrlParam(&quot;appId&quot;);</span></span><br><span class="line"><span class="comment">//            String source = data.getSingleUrlParam(&quot;source&quot;);</span></span><br><span class="line"><span class="comment">//            log.info(&quot;token &#123;&#125;, client &#123;&#125;&quot;, appId, source);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SocketIOServer(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringAnnotationScanner <span class="title">springAnnotationScanner</span><span class="params">(SocketIOServer socketServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringAnnotationScanner(socketServer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Socket启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketIOServer server;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerRunner</span><span class="params">(SocketIOServer server)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        server.start();</span><br><span class="line">        log.info(<span class="string">&quot;socket.io启动成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终架构"><a href="#最终架构" class="headerlink" title="最终架构"></a>最终架构</h4><p><img src="https://img.jacian.com/20190606145853.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>主动推送服务监听作为KafKa消费者，数据生产者讲加工好的数据推到KafKa中，消费者监听到消息广播给客户端；推送时在数据库查询用户对应的个性化设置，仅推送客户端选择接受的消息；</p><p>由于主动推送服务部署了多个节点，而多个节点分配在同一个KafKa消费组中，这样会引起多个节点仅消费到全部消息的一部分的问题；这里使用<code>Redis</code>的<code>发布/订阅</code>的机制解决了这个问题：当各个节点消费到消息之后，将消息发布之后，其它节点订阅该<code>Topic</code>将消息发送给各自节点上连接的客户端，在这里各个节点即是发布者，又是订阅者；</p><blockquote><p>从数据的产生，到消费</p></blockquote><p><img src="https://img.jacian.com/20190606150018.png"></p><h2 id="使用Redisson的Topic实现分布式发布-订阅"><a href="#使用Redisson的Topic实现分布式发布-订阅" class="headerlink" title="使用Redisson的Topic实现分布式发布/订阅"></a>使用Redisson的Topic实现分布式发布/订阅</h2><p>Redisson为了方便Redis中的<code>发布/订阅</code>机制的使用，将其封装成Topic，并提供了代码级别的<code>发布/订阅</code>操作，如此一来多个JVM进程连接到Redis（单机/集群）后，便可以实现在一个JVM进程中<code>发布</code>的<code>Topic</code>，在其他已经<code>订阅</code>了该主题的JVM进程中就能及时收到消息。</p><p>在Netty-SocketIO整合了<code>Redisson</code>之后，内部也使用了<code>发布/订阅</code>机制</p><h5 id="消息的发布"><a href="#消息的发布" class="headerlink" title="消息的发布"></a>消息的发布</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageToAllClient</span><span class="params">(String eventType, String message, String desc)</span> </span>&#123;</span><br><span class="line">    Collection&lt;SocketIOClient&gt; clients = server.getBroadcastOperations().getClients();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">final</span> SocketIOClient client : clients)&#123;</span><br><span class="line">      <span class="comment">// Do Somthing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Packet packet = <span class="keyword">new</span> Packet(PacketType.MESSAGE);</span><br><span class="line">    packet.setData(<span class="keyword">new</span> BroadcastMessage(message, eventType, desc));</span><br><span class="line">    publishMessage(packet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishMessage</span><span class="params">(Packet packet)</span> </span>&#123;</span><br><span class="line">    DispatchMessage dispatchMessage = <span class="keyword">new</span> DispatchMessage(<span class="string">&quot;&quot;</span>, packet, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    pubSubStore.publish(PubSubType.DISPATCH, dispatchMessage);</span><br><span class="line">    BroadcastMessage broadcastMessage = dispatchMessage.getPacket().getData();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息的订阅"><a href="#消息的订阅" class="headerlink" title="消息的订阅"></a>消息的订阅</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pubSubStore.subscribe(PubSubType.DISPATCH, dispatchMessage -&gt; &#123;</span><br><span class="line">      BroadcastMessage messageData = dispatchMessage.getPacket().getData();</span><br><span class="line">    </span><br><span class="line">      Collection&lt;SocketIOClient&gt; clients = server.getBroadcastOperations().getClients();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">final</span> SocketIOClient client : clients)&#123;</span><br><span class="line">        <span class="comment">// DO Somthing</span></span><br><span class="line">      &#125;, DispatchMessage.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WebSocket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> SocketIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joda Time使用小结</title>
      <link href="/2019/06/13/0717a30c9681/"/>
      <url>/2019/06/13/0717a30c9681/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Joda-Time基础操作"><a href="#一、Joda-Time基础操作" class="headerlink" title="一、Joda Time基础操作"></a>一、Joda Time基础操作</h2><span id="more"></span><h3 id="1、-构造指定时间"><a href="#1、-构造指定时间" class="headerlink" title="1、 构造指定时间"></a>1、 构造指定时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 明确给出年月日时分秒,同时还可以指定毫秒</span></span><br><span class="line">DateTime dateTime = <span class="keyword">new</span> DateTime(<span class="number">2017</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时间戳构造</span></span><br><span class="line">Datetime dateTime = <span class="keyword">new</span> DateTime(<span class="number">1505371053358L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字符串构造，使用字符串构造需要自己定义pattern</span></span><br><span class="line">String date = <span class="string">&quot;2017-09-14 20:30:00&quot;</span>;</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">DateTime dateTime = dateTimeFormatter.parseDateTime(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定时区构造时间</span></span><br><span class="line">DateTime dateTime = <span class="keyword">new</span> DateTime(DateTimeZone.forTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>)));</span><br></pre></td></tr></table></figure><blockquote><p>注意：”Asia/Shanghai”是国际时区Id，该ID可以通过JDK代码获取，代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] zones = TimeZone.getAvailableIDs();</span><br><span class="line"><span class="keyword">for</span> (String zone : zones) &#123;</span><br><span class="line">    System.out.println(zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、获取当前时间的时间戳"><a href="#2、获取当前时间的时间戳" class="headerlink" title="2、获取当前时间的时间戳"></a>2、获取当前时间的时间戳</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK</span></span><br><span class="line"><span class="keyword">long</span> currentTimeOfMills = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// Joda Time</span></span><br><span class="line"><span class="keyword">long</span> currentTimeOfMills = DateTime.now().getMillis();</span><br></pre></td></tr></table></figure><h3 id="3、获得当前时间的时区"><a href="#3、获得当前时间的时区" class="headerlink" title="3、获得当前时间的时区"></a>3、获得当前时间的时区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateTimeZone zone = DateTime.now().getZone();</span><br></pre></td></tr></table></figure><h3 id="4、-获取指定时区的当前时间"><a href="#4、-获取指定时区的当前时间" class="headerlink" title="4、 获取指定时区的当前时间"></a>4、 获取指定时区的当前时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateTimeZone gmt = DateTimeZone.forID(<span class="string">&quot;GMT&quot;</span>);</span><br><span class="line">DateTime dateTime = DateTime.now().toDateTime(gmt);</span><br></pre></td></tr></table></figure><h2 id="二、Joda-Time-对年月日的一些简单操作。"><a href="#二、Joda-Time-对年月日的一些简单操作。" class="headerlink" title="二、Joda Time 对年月日的一些简单操作。"></a>二、Joda Time 对年月日的一些简单操作。</h2><h3 id="1、-获取月初第一天和月末最后一天"><a href="#1、-获取月初第一天和月末最后一天" class="headerlink" title="1、 获取月初第一天和月末最后一天"></a>1、 获取月初第一天和月末最后一天</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DateTime dateTime = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="comment">// 月初第一天</span></span><br><span class="line">DateTime theFirstDateOfMonth = dateTime.dayOfMonth().withMinimumValue();</span><br><span class="line"><span class="comment">//  当前月最后一天</span></span><br><span class="line">DataTime theEndDataOfMonth = dateTime.dayOfMonth().withMaximumValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一天是几号</span></span><br><span class="line"><span class="keyword">int</span> day = dateTime.getDayOfMonth();</span><br><span class="line"><span class="comment">// 这一天是哪月</span></span><br><span class="line"><span class="keyword">int</span> month = dateTime.getMothOfYear();</span><br><span class="line"><span class="comment">// 这一天是哪年</span></span><br><span class="line"><span class="keyword">int</span> year = dateTime.getYear();</span><br><span class="line"><span class="comment">// 判断本月是不是9月</span></span><br><span class="line"><span class="keyword">if</span>(dateTime.getDayOfMonth() == DateTimeConstants.SEPTEMBER)&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取相对于当前时间的月份，比如获取上个月的时间或者下个月的是时间，方法minusMoths接受一个int的参数，如果这个参数等于0，代表本月，大于0代表已经过去的时间，小于0代表还没有到来的时间</span></span><br><span class="line"> LocalDate lastDayOfMonth = <span class="keyword">new</span> LocalDate().minusMonths(<span class="number">1</span>).dayOfMonth().withMaximumValue();</span><br></pre></td></tr></table></figure><h3 id="2、关于星期的操作"><a href="#2、关于星期的操作" class="headerlink" title="2、关于星期的操作"></a>2、关于星期的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTime dateTime = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="comment">// 今天是星期几</span></span><br><span class="line"><span class="keyword">int</span> week = dateTime.getDayOfWeek();</span><br><span class="line"><span class="comment">// 判断今天是不是星期三</span></span><br><span class="line"><span class="keyword">if</span>(dateTime.getDayOfWeek() == DateTimeConstants.WEDNESDAY)&#123;</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：DateTimeConstants中包含了许多你需要的常量，而不用你自己去定义，比如星期、月份、上午还是下午都有哦</p></blockquote><h3 id="3、计算时间差"><a href="#3、计算时间差" class="headerlink" title="3、计算时间差"></a>3、计算时间差</h3><p><strong>注意开始时间与结束时间参数位置，如果开始时间小于结束时间，得到的天数是正数，否则就是负数哦！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DateTime currentDateTime = <span class="keyword">new</span> DateTime();</span><br><span class="line">DateTime targetDateTime = <span class="keyword">new</span> DateTime(<span class="number">2017</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相差多少年</span></span><br><span class="line"><span class="keyword">int</span> years = Years.yearsBetween(currentDateTime,targetDateTime).getYears();</span><br><span class="line"><span class="comment">// 相差多少月</span></span><br><span class="line"><span class="keyword">int</span> months = Months.monthsBetween(currentDateTime,targetDateTime).getMonths();</span><br><span class="line"><span class="comment">// 距离国庆放假还有多少天，嘎嘎！</span></span><br><span class="line"><span class="keyword">int</span> days = Days.daysBetween(currentDateTime,targetDateTime).getDays();</span><br><span class="line"><span class="comment">// 相差多少小时</span></span><br><span class="line"><span class="keyword">int</span> hours = Hours.hoursBetween(currentDateTime,targetDateTime).getHours();</span><br><span class="line"><span class="comment">// 相差多少分钟</span></span><br><span class="line"><span class="keyword">int</span> minutes = Minutes.minutesBetween(currentDateTime,targetDateTime).getMinutes();</span><br><span class="line"><span class="comment">// 相差多少秒</span></span><br><span class="line"><span class="keyword">int</span> seconds = Seconds.secondsBetween(currentDateTime,targetDateTime).getSeconds();</span><br><span class="line"><span class="comment">// 相差多少周</span></span><br><span class="line"><span class="keyword">int</span> weeks = Weeks.weeksBetween(currentDateTime,targetDateTime).getWeeks();</span><br></pre></td></tr></table></figure><h3 id="4、获取零点相关的时间"><a href="#4、获取零点相关的时间" class="headerlink" title="4、获取零点相关的时间"></a>4、获取零点相关的时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DateTime currentDateTime = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="comment">// 今天的零点</span></span><br><span class="line">DateTime dateTime = currentDateTime.withMillisOfDay(<span class="number">0</span>)；</span><br><span class="line"><span class="comment">// 昨天的零点</span></span><br><span class="line">DateTime dateTime = currentDateTime.withMillisOfDay(<span class="number">0</span>).plusDays(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 明天的零点</span></span><br><span class="line">DateTime dateTime = currentDateTime.withMillisOfDay(<span class="number">0</span>).plusDays(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 这一年最后一天0点</span></span><br><span class="line"><span class="keyword">new</span> DateTime().dayOfYear().withMaximumValue().withMillisOfDay(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 这一年第一天0点</span></span><br><span class="line"><span class="keyword">new</span> DateTime().dayOfYear().withMinimumValue().withMillisOfDay(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 这个月最后一天0点</span></span><br><span class="line"><span class="keyword">new</span> DateTime().dayOfMonth().withMaximumValue().withMillisOfDay(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 这个月月初0点</span></span><br><span class="line"><span class="keyword">new</span> DateTime().dayOfMonth().withMinimumValue().withMillisOfDay(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：要获取多少天后或者多少天前的零点，只需在plusDays()方法中填写相应参数即可</p></blockquote><h2 id="三、准确使用Joda-Time的时间处理类"><a href="#三、准确使用Joda-Time的时间处理类" class="headerlink" title="三、准确使用Joda Time的时间处理类"></a>三、准确使用Joda Time的时间处理类</h2><h3 id="1、格式化就这么简单"><a href="#1、格式化就这么简单" class="headerlink" title="1、格式化就这么简单"></a>1、格式化就这么简单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化时间</span></span><br><span class="line">DateTime currentDateTime = <span class="keyword">new</span> DateTime();</span><br><span class="line">currentDateTime.toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定时区格式化</span></span><br><span class="line">String format = <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">DateTime dateTime = <span class="keyword">new</span> DateTime();</span><br><span class="line">dateTime.toString(format, Locale.US);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化时分秒（单位毫秒并且最大可格式23:59:59，超出将报错）</span></span><br><span class="line"><span class="keyword">int</span> millis = <span class="number">120000</span>;</span><br><span class="line">LocalTime localTime = <span class="keyword">new</span> LocalTime().withMillisOfDay(millis);</span><br><span class="line">localTime.toString(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2、-如果业务只需要日期，请使用LocalDate-因为LocalDate仅仅关心日期，更专业，也减少了不必要的资源消耗；如果业务只关心时间，那么使用LocalTime。例如："><a href="#2、-如果业务只需要日期，请使用LocalDate-因为LocalDate仅仅关心日期，更专业，也减少了不必要的资源消耗；如果业务只关心时间，那么使用LocalTime。例如：" class="headerlink" title="2、 如果业务只需要日期，请使用LocalDate,因为LocalDate仅仅关心日期，更专业，也减少了不必要的资源消耗；如果业务只关心时间，那么使用LocalTime。例如："></a>2、 如果业务只需要日期，请使用LocalDate,因为LocalDate仅仅关心日期，更专业，也减少了不必要的资源消耗；如果业务只关心时间，那么使用LocalTime。例如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = <span class="keyword">new</span> LocalDate();</span><br><span class="line">LocalTime localTime = <span class="keyword">new</span> LocalTime();</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"><span class="comment">// 2017-09-14</span></span><br><span class="line">System.out.println(localTime);</span><br><span class="line"><span class="comment">//10:54:14.506</span></span><br></pre></td></tr></table></figure><h3 id="3、-如果业务需要日期时间都要使用，那么可以使用LocalDateTime-DateTime这两个类，它们都是线程安全的同时都是不可变的，使用起来不用担心出问题。"><a href="#3、-如果业务需要日期时间都要使用，那么可以使用LocalDateTime-DateTime这两个类，它们都是线程安全的同时都是不可变的，使用起来不用担心出问题。" class="headerlink" title="3、 如果业务需要日期时间都要使用，那么可以使用LocalDateTime, DateTime这两个类，它们都是线程安全的同时都是不可变的，使用起来不用担心出问题。"></a>3、 如果业务需要日期时间都要使用，那么可以使用LocalDateTime, DateTime这两个类，它们都是线程安全的同时都是不可变的，使用起来不用担心出问题。</h3><p>LocalDateTime是与时区无关的。<br>DateTime是与时区相关的一个国际标准时间。<br>使用的时候根据自己的需要选择，详细的解释看官方文档吧！</p><h3 id="4、再次提醒要使用DateTimeConstants类定义好的常量，避免重复造轮子。下面给出DateTimeConstants类的常量（也不多），不在解释，望名知义。"><a href="#4、再次提醒要使用DateTimeConstants类定义好的常量，避免重复造轮子。下面给出DateTimeConstants类的常量（也不多），不在解释，望名知义。" class="headerlink" title="4、再次提醒要使用DateTimeConstants类定义好的常量，避免重复造轮子。下面给出DateTimeConstants类的常量（也不多），不在解释，望名知义。"></a>4、再次提醒要使用DateTimeConstants类定义好的常量，避免重复造轮子。下面给出DateTimeConstants类的常量（也不多），不在解释，望名知义。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 月份</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> JANUARY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEBRUARY = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MARCH = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APRIL = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> JUNE = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> JULY = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUGUST = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEPTEMBER = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OCTOBER = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOVEMBER = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DECEMBER = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 星期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUESDAY = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEDNESDAY = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THURSDAY = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRIDAY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SATURDAY = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// 上午&amp;下午</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AM = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PM = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 公元前...年(基督之前...年)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BC = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 公元前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BCE = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 公元...年(原义为主的纪年)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AD = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 基督纪元,公元</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CE = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 1秒对应毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLIS_PER_SECOND = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 1分钟对应秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECONDS_PER_MINUTE = <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 1分钟对应毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLIS_PER_MINUTE = <span class="number">60000</span>;</span><br><span class="line"><span class="comment">// 1小时对应分钟数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINUTES_PER_HOUR = <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 1小时对应的秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECONDS_PER_HOUR = <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 1小时对应的毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLIS_PER_HOUR = <span class="number">3600000</span>;</span><br><span class="line"><span class="comment">// 1天对应的小时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOURS_PER_DAY = <span class="number">24</span>;</span><br><span class="line"><span class="comment">// 1天对应的分钟数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINUTES_PER_DAY = <span class="number">1440</span>;</span><br><span class="line"><span class="comment">// 1天对应的秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECONDS_PER_DAY = <span class="number">86400</span>;</span><br><span class="line"><span class="comment">// 1天对应的毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLIS_PER_DAY = <span class="number">86400000</span>;</span><br><span class="line"><span class="comment">// 1周对应的天数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DAYS_PER_WEEK = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// 1周对应的小时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOURS_PER_WEEK = <span class="number">168</span>;</span><br><span class="line"><span class="comment">// 1周对应的分钟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINUTES_PER_WEEK = <span class="number">10080</span>;</span><br><span class="line"><span class="comment">// 1周对应的秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECONDS_PER_WEEK = <span class="number">604800</span>;</span><br><span class="line"><span class="comment">// 1周对应的毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLIS_PER_WEEK = <span class="number">604800000</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Joda </tag>
            
            <tag> DateTime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-Feign使用</title>
      <link href="/2019/05/24/329c8ab61662/"/>
      <url>/2019/05/24/329c8ab61662/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot：2.1.5.RELEASE</span><br><span class="line">Feign：2.0.1.RELEASE</span><br><span class="line">feign-okHttp：9.7.0</span><br></pre></td></tr></table></figure><h2 id="Feign-简介"><a href="#Feign-简介" class="headerlink" title="Feign 简介"></a>Feign 简介</h2><p>Spring Cloud的Feign支持的一个中心概念就是命名客户端.Feign客户端使用@FeignClient注册组合成组件,按需调用远程服务器.<br>Spring Cloud使用FeignClientsConfiguration创建一个新的集合作为每个命名客户端的ApplicationContext(应用上下文), 包含feign.Decoder，feign.Encoder和feign.Contract.</p><p>你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。你也可以直接使用 Apache HttpClient 来实现。但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。</p><span id="more"></span><p>Feign 通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。然而这也限制了 Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。</p><p>Spring Cloud应用在启动时，Feign会扫描标有@FeignClient注解的接口，生成代理，并注册到Spring容器中。生成代理时Feign会为每个接口方法创建一个RequetTemplate对象，该对象封装了HTTP请求需要的全部信息，请求参数名、请求方法等信息都是在这个过程中确定的，Feign的模板化就体现在这里。</p><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Feign客户端接口-调用方"><a href="#Feign客户端接口-调用方" class="headerlink" title="Feign客户端接口(调用方)"></a>Feign客户端接口(调用方)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;testDemo&quot;, url = &quot;localhost:8080/student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestFeignRepository</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function">String <span class="title">get1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function">String <span class="title">get2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动类添加-EnableFeignClients注解"><a href="#启动类添加-EnableFeignClients注解" class="headerlink" title="启动类添加@EnableFeignClients注解"></a>启动类添加@EnableFeignClients注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestprojectApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestprojectApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FeignClient注解参数"><a href="#FeignClient注解参数" class="headerlink" title="@FeignClient注解参数"></a>@FeignClient注解参数</h2><ul><li>name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现</li><li>url: url一般用于调试，可以手动指定@FeignClient调用的地址</li><li>decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException</li><li>configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contract</li><li>fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口</li><li>fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码</li><li>path: 定义当前FeignClient的统一前缀</li></ul><h2 id="Feign使用OkHttp3和Hystrix"><a href="#Feign使用OkHttp3和Hystrix" class="headerlink" title="Feign使用OkHttp3和Hystrix"></a>Feign使用OkHttp3和Hystrix</h2><h4 id="Maven依赖-1"><a href="#Maven依赖-1" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件：application-yml"><a href="#配置文件：application-yml" class="headerlink" title="配置文件：application.yml"></a>配置文件：application.yml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  httpClient:</span><br><span class="line">    enabled: false</span><br><span class="line">  okhttp:</span><br><span class="line">    enabled: true</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Feign.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(FeignAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignOkHttpConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> okhttp3.<span class="function">OkHttpClient <span class="title">okHttpClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> okhttp3.OkHttpClient.Builder()</span><br><span class="line">                .readTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .connectTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">120</span>, TimeUnit.SECONDS)</span><br><span class="line">                .connectionPool(<span class="keyword">new</span> ConnectionPool())</span><br><span class="line"><span class="comment">//                .addInterceptor() // 拦截器</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket主动推送服务</title>
      <link href="/2019/05/23/49cd02c78d08/"/>
      <url>/2019/05/23/49cd02c78d08/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器与Web页面交互方式"><a href="#服务器与Web页面交互方式" class="headerlink" title="服务器与Web页面交互方式"></a>服务器与Web页面交互方式</h2><blockquote><p>传统的 Web 服务都是客户端发出请求，服务端给出响应。</p></blockquote><p><strong>HTTP</strong></p><ul><li>HTTP短连接：在HTTP1.0中，客户端发送请求，服务器接收请求， 双⽅建⽴连接，服务器响应资源，请求结束。</li><li>HTTP⻓连接：在HTTP 1.1中，客户端发出请求，服务端接收请 求，双⽅建⽴连接，在服务端没有返回之前保持连接，当客户端再 发送请求时，它会使⽤同⼀个连接。这⼀直继续到客户端或服务器 端认为会话已经结束，其中⼀⽅中断连接。<span id="more"></span></li></ul><p><img src="https://img.jacian.com/20190606145725.png" alt="服务器与Web页面交互方式"></p><h2 id="服务器向-Web-页面推送消息的方式"><a href="#服务器向-Web-页面推送消息的方式" class="headerlink" title="服务器向 Web 页面推送消息的方式"></a>服务器向 Web 页面推送消息的方式</h2><ul><li><p>非阻塞轮询（短轮询）：客户端以固定的频率（比如10秒钟一次）向服务端发送请求，如果服务端没有数据响应，就直接响应一个空，如果有数据响应，就将响应数据作为结果返回给客户端。特点是每次请求后，都会立即给响应。</p></li><li><p>阻塞长轮询（长轮询）：客户端像传统轮询一样从服务器请求数据。如果服务器没有可以立即返回给客户端的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（请求阻塞或者超时），等有响应数据之后将数据作为结果返回给客户端。特点是一次请求后直到有响应数据时才会给返回，否则阻塞等待。</p></li><li><p>短轮询</p><p>优点是实现逻辑简单，但是当间隔太短时，会有⼤量的请求发送到 服务器，会对服务器负载造成影响；⽽间隔太⻓，业务数据的实时 性得不到保证⽆效请求的数量多。在⽤户量较⼤的情况下，服务器 负载较⾼。</p></li><li><p>⻓轮询</p><p>优点是消息实时性⾼，⽆消息的情况下不会进⾏频繁的请求；缺点 是服务端维持和客户端的连接会消耗掉⼀部分资源。</p></li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li>WebSocket 是 HTML5 ⼀种新的协议（Web TCP）。它建⽴ 在 TCP 之上，实现了客户端和服务端全双⼯异步通信.</li></ul><ul><li><p>它和 HTTP 最⼤不同是：</p><p>WebSocket 是⼀种双向通信协议，WebSocket 服务器和 Browser/ Client Agent 都能主动的向对⽅发送或接收数据；</p></li><li><p>WebSocket 需要类似 TCP 的客户端和服务器端通过握⼿连接，连 接成功后才能相互通信。</p></li></ul><p><img src="https://img.jacian.com/20190606150545.png" alt="WebSocket通信方式"></p><h2 id="服务端与客户端通信架构"><a href="#服务端与客户端通信架构" class="headerlink" title="服务端与客户端通信架构"></a>服务端与客户端通信架构</h2><p><img src="https://img.jacian.com/20190606145853.png" alt="服务端与客户端通信架构"></p><h2 id="加⼯后的数据经过-KAFKA-推送到-WEBSOCKET-的消费端"><a href="#加⼯后的数据经过-KAFKA-推送到-WEBSOCKET-的消费端" class="headerlink" title="加⼯后的数据经过 KAFKA 推送到 WEBSOCKET 的消费端"></a>加⼯后的数据经过 KAFKA 推送到 WEBSOCKET 的消费端</h2><p><img src="https://img.jacian.com/20190606150018.png" alt="加⼯后的数据经过 KAFKA 推送到 WEBSOCKET 的消费端"></p><h2 id="数据流（从⽣产数据到⽤户端展⽰）"><a href="#数据流（从⽣产数据到⽤户端展⽰）" class="headerlink" title="数据流（从⽣产数据到⽤户端展⽰）"></a>数据流（从⽣产数据到⽤户端展⽰）</h2><p><img src="https://img.jacian.com/20190606150108.png" alt="数据流（从⽣产数据到⽤户端展⽰）"></p>]]></content>
      
      
      <categories>
          
          <category> WebSocket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> SocketIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中使用@Async实现异步调用</title>
      <link href="/2019/05/05/316b3e1854f8/"/>
      <url>/2019/05/05/316b3e1854f8/</url>
      
        <content type="html"><![CDATA[<p>什么是“异步调用”？</p><p>“异步调用”对应的是“同步调用”，<em>同步调用</em>指程序按照定义顺序依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；<em>异步调用</em>指程序在顺序执行时，不等待异步调用的语句返回结果就执行后面的程序。<span id="more"></span></p><h4 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h4><p>下面通过一个简单示例来直观的理解什么是同步调用：</p><ul><li>定义Task类，创建三个处理函数分别模拟三个执行任务的操作，操作消耗时间随机取（10秒内）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">    public static Random random =new Random();</span><br><span class="line"></span><br><span class="line">    public void doTaskOne() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;开始做任务一&quot;);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(10000));</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doTaskTwo() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;开始做任务二&quot;);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(10000));</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doTaskThree() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;开始做任务三&quot;);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(10000));</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在单元测试用例中，注入Task对象，并在测试用例中执行<code>doTaskOne</code>、<code>doTaskTwo</code>、<code>doTaskThree</code>三个函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(classes = Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private Task task;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line">task.doTaskOne();</span><br><span class="line">task.doTaskTwo();</span><br><span class="line">task.doTaskThree();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行单元测试，可以看到类似如下输出：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">完成任务一，耗时：4256毫秒</span><br><span class="line">开始做任务二</span><br><span class="line">完成任务二，耗时：4957毫秒</span><br><span class="line">开始做任务三</span><br><span class="line">完成任务三，耗时：7173毫秒</span><br></pre></td></tr></table></figure><p>任务一、任务二、任务三顺序的执行完了，换言之<code>doTaskOne</code>、<code>doTaskTwo</code>、<code>doTaskThree</code>三个函数顺序的执行完成。</p><h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>上述的同步调用虽然顺利的执行完了三个任务，但是可以看到执行时间比较长，若这三个任务本身之间不存在依赖关系，可以并发执行的话，同步调用在执行效率方面就比较差，可以考虑通过异步调用的方式来并发执行。</p><p>在Spring Boot中，我们只需要通过使用<code>@Async</code>注解就能简单的将原来的同步函数变为异步函数，Task类改在为如下模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void doTaskOne() throws Exception &#123;</span><br><span class="line">        // 同上内容，省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void doTaskTwo() throws Exception &#123;</span><br><span class="line">        // 同上内容，省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public void doTaskThree() throws Exception &#123;</span><br><span class="line">        // 同上内容，省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让@Async注解能够生效，还需要在Spring Boot的主程序中配置@EnableAsync，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAsync</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以反复执行单元测试，您可能会遇到各种不同的结果，比如：</p><ul><li>没有任何任务相关的输出</li><li>有部分任务相关的输出</li><li>乱序的任务相关的输出</li></ul><p>原因是目前<code>doTaskOne</code>、<code>doTaskTwo</code>、<code>doTaskThree</code>三个函数的时候已经是异步执行了。主程序在异步调用之后，主程序并不会理会这三个函数是否执行完成了，由于没有其他需要执行的内容，所以程序就自动结束了，导致了不完整或是没有输出任务相关内容的情况。</p><p><strong>注： @Async所修饰的函数不要定义为static类型，这样异步调用不会生效</strong></p><h4 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h4><p>为了让<code>doTaskOne</code>、<code>doTaskTwo</code>、<code>doTaskThree</code>能正常结束，假设我们需要统计一下三个任务并发执行共耗时多少，这就需要等到上述三个函数都完成调动之后记录时间，并计算结果。</p><p>那么我们如何判断上述三个异步调用是否已经执行完成呢？我们需要使用<code>Future&lt;T&gt;</code>来返回异步调用的结果，就像如下方式改造<code>doTaskOne</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br><span class="line">public Future&lt;String&gt; doTaskOne() throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;开始做任务一&quot;);</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    Thread.sleep(random.nextInt(10000));</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line">    return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照如上方式改造一下其他两个异步函数之后，下面我们改造一下测试用例，让测试在等待完成三个异步调用之后来做一些其他事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; task1 = task.doTaskOne();</span><br><span class="line">Future&lt;String&gt; task2 = task.doTaskTwo();</span><br><span class="line">Future&lt;String&gt; task3 = task.doTaskThree();</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) &#123;</span><br><span class="line">// 三个任务都调用完成，退出循环等待</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看我们做了哪些改变：</p><ul><li>在测试用例一开始记录开始时间</li><li>在调用三个异步函数的时候，返回<code>Future&lt;String&gt;</code>类型的结果对象</li><li>在调用完三个异步函数之后，开启一个循环，根据返回的<code>Future&lt;String&gt;</code>对象来判断三个异步函数是否都结束了。若都结束，就结束循环；若没有都结束，就等1秒后再判断。</li><li>跳出循环之后，根据结束时间 - 开始时间，计算出三个任务并发执行的总耗时。</li></ul><p>执行一下上述的单元测试，可以看到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始做任务一</span><br><span class="line">开始做任务二</span><br><span class="line">开始做任务三</span><br><span class="line">完成任务三，耗时：37毫秒</span><br><span class="line">完成任务二，耗时：3661毫秒</span><br><span class="line">完成任务一，耗时：7149毫秒</span><br><span class="line">任务全部完成，总耗时：8025毫秒</span><br></pre></td></tr></table></figure><p>可以看到，通过异步调用，让任务一、二、三并发执行，有效的减少了程序的总运行时间。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>本文的相关例子可以查看下面仓库中的<code>chapter4-1-2</code>目录：</p><ul><li>github: <a href="https://github.com/WuliGitH/SpringBoot-Learning-1">https://github.com/WuliGitH/SpringBoot-Learning-1</a></li></ul><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 ,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中使用@Scheduled创建定时任务</title>
      <link href="/2019/04/02/3f72e049239e/"/>
      <url>/2019/04/02/3f72e049239e/</url>
      
        <content type="html"><![CDATA[<p>我们在编写Spring Boot应用中经常会遇到这样的场景，比如：我需要定时地发送一些短信、邮件之类的操作，也可能会定时地检查和监控一些标志、参数等。<span id="more"></span></p><h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>在Spring Boot中编写定时任务是非常简单的事，下面通过实例介绍如何在Spring Boot中创建定时任务，实现每过5秒输出一下当前时间。</p><ul><li>在Spring Boot的主类中加入<code>@EnableScheduling</code>注解，启用定时任务的配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建定时任务实现类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ScheduledTasks &#123;</span><br><span class="line"></span><br><span class="line">    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    @Scheduled(fixedRate = 5000)</span><br><span class="line">    public void reportCurrentTime() &#123;</span><br><span class="line">        System.out.println(&quot;现在时间：&quot; + dateFormat.format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行程序，控制台中可以看到类似如下输出，定时任务开始正常运作了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2016-05-15 10:40:04.073  INFO 1688 --- [           main] com.didispace.Application                : Started Application in 1.433 seconds (JVM running for 1.967)</span><br><span class="line">现在时间：10:40:09</span><br><span class="line">现在时间：10:40:14</span><br><span class="line">现在时间：10:40:19</span><br><span class="line">现在时间：10:40:24</span><br><span class="line">现在时间：10:40:29522</span><br><span class="line">现在时间：10:40:34</span><br></pre></td></tr></table></figure><p>关于上述的简单入门示例也可以参见官方的<a href="http://spring.io/guides/gs/scheduling-tasks/">Scheduling Tasks</a></p><h2 id="Scheduled详解"><a href="#Scheduled详解" class="headerlink" title="@Scheduled详解"></a>@Scheduled详解</h2><p>在上面的入门例子中，使用了<code>@Scheduled(fixedRate = 5000)</code> 注解来定义每过5秒执行的任务，对于<code>@Scheduled</code>的使用可以总结如下几种方式：</p><ul><li><code>@Scheduled(fixedRate = 5000)</code> ：上一次开始执行时间点之后5秒再执行</li><li><code>@Scheduled(fixedDelay = 5000)</code> ：上一次执行完毕时间点之后5秒再执行</li><li><code>@Scheduled(initialDelay=1000, fixedRate=5000)</code> ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</li><li><code>@Scheduled(cron=&quot;*/5 * * * * *&quot;)</code> ：通过cron表达式定义规则</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>本文的相关例子可以查看下面仓库中的<code>chapter4-1-1</code>目录：</p><p>github: <a href="https://github.com/WuliGitH/SpringBoot-Learning-1">https://github.com/WuliGitH/SpringBoot-Learning-1</a></p><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 ,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot属性配置文件详解</title>
      <link href="/2019/03/28/a687fcc1234f/"/>
      <url>/2019/03/28/a687fcc1234f/</url>
      
        <content type="html"><![CDATA[<p>相信很多人选择Spring Boot主要是考虑到它既能兼顾Spring的强大功能，还能实现快速开发的便捷。我们在Spring Boot使用过程中，最直观的感受就是没有了原来自己整合Spring应用时繁多的XML配置内容，替代它的是在<code>pom.xml</code>中引入模块化的<code>Starter POMs</code>，其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在<code>application.properties</code>中完成一些属性配置就能开启各模块的应用。<span id="more"></span></p><p>在之前的各篇文章中都有提及关于<code>application.properties</code>的使用，主要用来配置数据库连接、日志相关配置等。除了这些配置内容之外，本文将具体介绍一些在<code>application.properties</code>配置中的其他特性和使用方法。</p><h2 id="自定义属性与加载"><a href="#自定义属性与加载" class="headerlink" title="自定义属性与加载"></a>自定义属性与加载</h2><p>我们在使用Spring Boot的时候，通常也需要定义一些自己使用的属性，我们可以如下方式直接定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.didispace.blog.name=WuliGit</span><br><span class="line">com.didispace.blog.title=Spring Boot教程</span><br></pre></td></tr></table></figure><p>然后通过<code>@Value(&quot;$&#123;属性名&#125;&quot;)</code>注解来加载对应的配置属性，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BlogProperties &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;com.didispace.blog.name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;$&#123;com.didispace.blog.title&#125;&quot;)</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照惯例，通过单元测试来验证BlogProperties中的属性是否已经根据配置文件加载了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private BlogProperties blogProperties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void getHello() throws Exception &#123;</span><br><span class="line">Assert.assertEquals(blogProperties.getName(), &quot;WuliGit&quot;);</span><br><span class="line">Assert.assertEquals(blogProperties.getTitle(), &quot;Spring Boot教程&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数间的引用"><a href="#参数间的引用" class="headerlink" title="参数间的引用"></a>参数间的引用</h2><p>在<code>application.properties</code>中的各个参数之间也可以直接引用来使用，就像下面的设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.didispace.blog.name=WuliGit</span><br><span class="line">com.didispace.blog.title=Spring Boot教程</span><br><span class="line">com.didispace.blog.desc=$&#123;com.didispace.blog.name&#125;正在努力写《$&#123;com.didispace.blog.title&#125;》</span><br></pre></td></tr></table></figure><p><code>com.didispace.blog.desc</code>参数引用了上文中定义的<code>name</code>和<code>title</code>属性，最后该属性的值就是<code>WuliGit正在努力写《Spring Boot教程》</code>。</p><h2 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h2><p>在一些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。Spring Boot的属性配置文件中可以通过<code>$&#123;random&#125;</code>来产生int值、long值或者string字符串，来支持属性的随机值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 随机字符串</span><br><span class="line">com.didispace.blog.value=$&#123;random.value&#125;</span><br><span class="line"># 随机int</span><br><span class="line">com.didispace.blog.number=$&#123;random.int&#125;</span><br><span class="line"># 随机long</span><br><span class="line">com.didispace.blog.bignumber=$&#123;random.long&#125;</span><br><span class="line"># 10以内的随机数</span><br><span class="line">com.didispace.blog.test1=$&#123;random.int(10)&#125;</span><br><span class="line"># 10-20的随机数</span><br><span class="line">com.didispace.blog.test2=$&#123;random.int[10,20]&#125;</span><br></pre></td></tr></table></figure><h2 id="通过命令行设置属性值"><a href="#通过命令行设置属性值" class="headerlink" title="通过命令行设置属性值"></a>通过命令行设置属性值</h2><p>相信使用过一段时间Spring Boot的用户，一定知道这条命令：<code>java -jar xxx.jar --server.port=8888</code>，通过使用–server.port属性来设置xxx.jar应用的端口为8888。</p><p>在命令行运行时，连续的两个减号<code>--</code>就是对<code>application.properties</code>中的属性值进行赋值的标识。所以，<code>java -jar xxx.jar --server.port=8888</code>命令，等价于我们在<code>application.properties</code>中添加属性<code>server.port=8888</code>，该设置在样例工程中可见，读者可通过删除该值或使用命令行来设置该值来验证。</p><p>通过命令行来修改属性值固然提供了不错的便利性，但是通过命令行就能更改应用运行的参数，那岂不是很不安全？是的，所以Spring Boot也贴心的提供了屏蔽命令行访问属性的设置，只需要这句设置就能屏蔽：<code>SpringApplication.setAddCommandLineProperties(false)</code>。</p><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。</p><p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p><p>在Spring Boot中多环境配置文件名需要满足<code>application-&#123;profile&#125;.properties</code>的格式，其中<code>&#123;profile&#125;</code>对应你的环境标识，比如：</p><ul><li><code>application-dev.properties</code>：开发环境</li><li><code>application-test.properties</code>：测试环境</li><li><code>application-prod.properties</code>：生产环境</li></ul><p>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应<code>&#123;profile&#125;</code>值。</p><p>如：<code>spring.profiles.active=test</code>就会加载<code>application-test.properties</code>配置文件内容</p><p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p><ul><li>针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></li><li>在这三个文件均都设置不同的<code>server.port</code>属性，如：dev环境设置为1111，test环境设置为2222，prod环境设置为3333</li><li>application.properties中设置<code>spring.profiles.active=dev</code>，就是说默认以dev环境设置</li><li>测试不同配置的加载<ul><li>执行<code>java -jar xxx.jar</code>，可以观察到服务端口被设置为<code>1111</code>，也就是默认的开发环境（dev）</li><li>执行<code>java -jar xxx.jar --spring.profiles.active=test</code>，可以观察到服务端口被设置为<code>2222</code>，也就是测试环境的配置（test）</li><li>执行<code>java -jar xxx.jar --spring.profiles.active=prod</code>，可以观察到服务端口被设置为<code>3333</code>，也就是生产环境的配置（prod）</li></ul></li></ul><p>按照上面的实验，可以如下总结多环境的配置思路：</p><ul><li><code>application.properties</code>中配置通用内容，并设置<code>spring.profiles.active=dev</code>，以开发环境为默认配置</li><li><code>application-&#123;profile&#125;.properties</code>中配置各个环境不同的内容</li><li>通过命令行方式去激活不同环境的配置</li></ul><p><a href="https://github.com/WuliGitH/SpringBoot-Learning-1">完整示例chapter2-1-1</a></p><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 ,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中Web应用的统一异常处理</title>
      <link href="/2019/03/27/80ca930b2a1d/"/>
      <url>/2019/03/27/80ca930b2a1d/</url>
      
        <content type="html"><![CDATA[<p>我们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射：<code>/error</code>，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。<span id="more"></span></p><p>选择一个之前实现过的Web应用（<a href="http://git.oschina.net/didispace/SpringBoot-Learning/tree/master/Chapter3-1-2">Chapter3-1-2</a>）为基础，启动该应用，访问一个不存在的URL，或是修改处理内容，直接抛出异常，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public String hello() throws Exception &#123;</span><br><span class="line">    throw new Exception(&quot;发生错误&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。</p><p><img src="https://ws1.sinaimg.cn/large/006RbZVIly1g1h9bp9bhgj311608odjg.jpg" alt="img"></p><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面你的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。</p><p>下面我们以之前的Web应用例子为基础（<a href="http://git.oschina.net/didispace/SpringBoot-Learning/tree/master/Chapter3-1-2">Chapter3-1-2</a>），进行统一异常处理的改造。</p><ul><li>创建全局异常处理类：通过使用<code>@ControllerAdvice</code>定义统一的异常处理类，而不是在每个Controller中逐个定义。<code>@ExceptionHandler</code>用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到<code>error.html</code>中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = Exception.class)</span><br><span class="line">    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123;</span><br><span class="line">        ModelAndView mav = new ModelAndView();</span><br><span class="line">        mav.addObject(&quot;exception&quot;, e);</span><br><span class="line">        mav.addObject(&quot;url&quot;, req.getRequestURL());</span><br><span class="line">        mav.setViewName(DEFAULT_ERROR_VIEW);</span><br><span class="line">        return mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现<code>error.html</code>页面展示：在<code>templates</code>目录下创建<code>error.html</code>，将请求的URL和Exception对象的message输出。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;统一异常处理&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Error Handler&lt;/h1&gt;</span><br><span class="line">    &lt;div th:text=&quot;$&#123;url&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div th:text=&quot;$&#123;exception.message&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>启动该应用，访问：<code>http://localhost:8080/hello</code>，可以看到如下错误提示页面。</p><p><img src="http://img.jacian.com/20190521113417.png" alt="自定义错误页面"></p><p><em>通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。</em></p><h2 id="返回JSON格式"><a href="#返回JSON格式" class="headerlink" title="返回JSON格式"></a>返回JSON格式</h2><p>在上述例子中，通过<code>@ControllerAdvice</code>统一定义不同Exception映射到不同错误处理页面。而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。</p><p>本质上，只需在<code>@ExceptionHandler</code>之后加入<code>@ResponseBody</code>，就能让处理函数return的内容转换为JSON格式。</p><p>下面以一个具体示例来实现返回JSON格式的异常处理。</p><ul><li>创建统一的JSON返回对象，code：消息类型，message：消息内容，url：请求的url，data：请求返回的数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ErrorInfo&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static final Integer OK = 0;</span><br><span class="line">    public static final Integer ERROR = 100;</span><br><span class="line"></span><br><span class="line">    private Integer code;</span><br><span class="line">    private String message;</span><br><span class="line">    private String url;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个自定义异常，用来实验捕获该异常，并返回json</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line"></span><br><span class="line">    public MyException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Controller</code>中增加json映射，抛出<code>MyException</code>异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/json&quot;)</span><br><span class="line">    public String json() throws MyException &#123;</span><br><span class="line">        throw new MyException(&quot;发生错误2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为<code>MyException</code>异常创建对应的处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = MyException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ErrorInfo&lt;String&gt; jsonErrorHandler(HttpServletRequest req, MyException e) throws Exception &#123;</span><br><span class="line">        ErrorInfo&lt;String&gt; r = new ErrorInfo&lt;&gt;();</span><br><span class="line">        r.setMessage(e.getMessage());</span><br><span class="line">        r.setCode(ErrorInfo.ERROR);</span><br><span class="line">        r.setData(&quot;Some Data&quot;);</span><br><span class="line">        r.setUrl(req.getRequestURL().toString());</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动应用，访问：<a href="http://localhost:8080/json%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E8%BF%94%E5%9B%9E%E5%86%85%E5%AE%B9%EF%BC%9A">http://localhost:8080/json，可以得到如下返回内容：</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 100，</span><br><span class="line">    data: &quot;Some Data&quot;，</span><br><span class="line">    message: &quot;发生错误2&quot;，</span><br><span class="line">    url: &quot;http://localhost:8080/json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，已完成在Spring Boot中创建统一的异常处理，实际实现还是依靠Spring MVC的注解，更多更深入的使用可参考Spring MVC的文档。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>本文的相关例子可以查看下面仓库中的<code>chapter3-1-6</code>目录：</p><ul><li>Github：<a href="https://github.com/WuliGitH/SpringBoot-Learning-1">https://github.com/WuliGitH/SpringBoot-Learning-1</a></li></ul><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 ,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装MySQL</title>
      <link href="/2019/03/25/8c14db995ec4/"/>
      <url>/2019/03/25/8c14db995ec4/</url>
      
        <content type="html"><![CDATA[<h2 id="下载-repo-源"><a href="#下载-repo-源" class="headerlink" title="下载 repo 源"></a>下载 repo 源</h2><p>进入 <a href="https://repo.mysql.com/">https://repo.mysql.com/</a>  ，里面包含了所有可用的 MySQL 源。选择一个合适的版本，进行下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget https://repo.mysql.com/mysql57-community-release-el7.rpm</span></span><br></pre></td></tr></table></figure><span id="more"></span><blockquote><p> 如果提示<code>-bash: wget: 未找到命令</code> 执行以下命令, 安装wget:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="comment"># yum -y install wget</span></span></span><br></pre></td></tr></table></figure></blockquote><p>完成之后，进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -ivh mysql57-community-release-el7.rpm</span></span><br></pre></td></tr></table></figure><p><img src="https://img.jacian.com/20190521112252.png"></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><h4 id="开始安装MySQL"><a href="#开始安装MySQL" class="headerlink" title="开始安装MySQL"></a>开始安装MySQL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install mysql -y</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install mysql-server -y</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install mysql-devel -y</span></span><br></pre></td></tr></table></figure><p><code>MySQL</code> 是MySQL客户端</p><p><code>MySQL-server</code> 是数据库服务器</p><p><code>MySQL-devel</code> 包含了开发用到的库以及头文件</p><p><img src="https://img.jacian.com/20190521112131.png"></p><p>到此为止MySQL就安装完成了。</p><h2 id="启动-停止-MySQL"><a href="#启动-停止-MySQL" class="headerlink" title="启动/停止 MySQL"></a>启动/停止 MySQL</h2><h4 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动MySQL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl start mysqld.service</span></span><br></pre></td></tr></table></figure><h4 id="查看MySQL运行状态"><a href="#查看MySQL运行状态" class="headerlink" title="查看MySQL运行状态"></a>查看MySQL运行状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl status mysqld.service</span></span><br></pre></td></tr></table></figure><p><img src="https://img.jacian.com/20190521112526.png"></p><blockquote><p>这就说明MySQL成功运行了。</p></blockquote><h4 id="停止MySQL"><a href="#停止MySQL" class="headerlink" title="停止MySQL"></a>停止MySQL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop mysqld.service</span></span><br></pre></td></tr></table></figure><h4 id="重启MySQL"><a href="#重启MySQL" class="headerlink" title="重启MySQL"></a>重启MySQL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart mysqld.service</span></span><br></pre></td></tr></table></figure><h2 id="登陆MySQL"><a href="#登陆MySQL" class="headerlink" title="登陆MySQL"></a>登陆MySQL</h2><h4 id="通过查看日志获取初始密码"><a href="#通过查看日志获取初始密码" class="headerlink" title="通过查看日志获取初始密码"></a>通过查看日志获取初始密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> grep <span class="string">&quot;password&quot;</span> /var/<span class="built_in">log</span>/mysqld.log</span></span><br></pre></td></tr></table></figure><p><img src="https://img.jacian.com/20190521112654.png"></p><h4 id="输入以下命令并输入初始密码进入数据库"><a href="#输入以下命令并输入初始密码进入数据库" class="headerlink" title="输入以下命令并输入初始密码进入数据库"></a>输入以下命令并输入初始密码进入数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql -uroot -p</span></span><br></pre></td></tr></table></figure><p><img src="https://img.jacian.com/20190521112729.png"></p><blockquote><p>此时不能做任何事, 要将初始密码修改掉之后才可以进行操作。</p></blockquote><h2 id="修改初始密码"><a href="#修改初始密码" class="headerlink" title="修改初始密码"></a>修改初始密码</h2><h4 id="修改密码可以使用以下命令"><a href="#修改密码可以使用以下命令" class="headerlink" title="修改密码可以使用以下命令"></a>修改密码可以使用以下命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>当我们输入的密码过于简单的时候会出现错误, 那是因为MySQL有相应的密码校验, 要求由大小写字母数字特殊符号组成, 否则无法完成修改 ; 如果仅用于自己测试, 想设置一个简单的密码可以参考下列操作 ;</p></blockquote><p><img src="https://img.jacian.com/20190521112800.png"></p><h4 id="设置简单密码"><a href="#设置简单密码" class="headerlink" title="设置简单密码"></a>设置简单密码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 修改MySQL参数配置</span><br><span class="line">mysql&gt; set global validate_password_policy=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global validate_password_mixed_case_count=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global validate_password_number_count=3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global validate_password_special_char_count=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global validate_password_length=3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 设置简单密码</span><br><span class="line">mysql&gt; SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;root&#x27;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OK，大功告成。</p><h2 id="设置允许远程访问MySQL"><a href="#设置允许远程访问MySQL" class="headerlink" title="设置允许远程访问MySQL"></a>设置允许远程访问MySQL</h2><h4 id="允许任何主机连接"><a href="#允许任何主机连接" class="headerlink" title="允许任何主机连接"></a>允许任何主机连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h4 id="允许指定IP连接"><a href="#允许指定IP连接" class="headerlink" title="允许指定IP连接"></a>允许指定IP连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;jack&#x27;@’10.10.50.127’ IDENTIFIED BY &#x27;654321&#x27; WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><blockquote><p>如果远程连接出现错误请检查是否关闭防火墙。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中使用MongoDB数据库</title>
      <link href="/2019/03/24/96beb9352dd7/"/>
      <url>/2019/03/24/96beb9352dd7/</url>
      
        <content type="html"><![CDATA[<p>前段时间分享了关于<a href="http://wuligit.com/2019/02/1551337200000/">Spring Boot中使用Redis</a>的文章，除了Redis之后，我们在互联网产品中还经常会用到另外一款著名的NoSQL数据库MongoDB。</p><p>下面就来简单介绍一下MongoDB，并且通过一个例子来介绍Spring Boot中对MongoDB访问的配置和使用。<span id="more"></span></p><h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><p>MongoDB是一个基于分布式文件存储的数据库，它是一个介于关系数据库和非关系数据库之间的产品，其主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS系统（具有丰富的功能）之间架起一座桥梁，它集两者的优势于一身。</p><p>MongoDB支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型，也因为他的存储格式也使得它所存储的数据在Nodejs程序应用中使用非常流畅。</p><p>既然称为NoSQL数据库，Mongo的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>但是，MongoDB也不是万能的，同MySQL等关系型数据库相比，它们在针对不同的数据类型和事务要求上都存在自己独特的优势。在数据存储的选择中，坚持多样化原则，选择更好更经济的方式，而不是自上而下的统一化。</p><p>较常见的，我们可以直接用MongoDB来存储键值对类型的数据，如：验证码、Session等；由于MongoDB的横向扩展能力，也可以用来存储数据规模会在未来变的非常巨大的数据，如：日志、评论等；由于MongoDB存储数据的弱类型，也可以用来存储一些多变json数据，如：与外系统交互时经常变化的JSON报文。而对于一些对数据有复杂的高事务性要求的操作，如：账户交易等就不适合使用MongoDB来存储。</p><p><a href="https://www.mongodb.org/">MongoDB官网</a></p><h2 id="访问MongoDB"><a href="#访问MongoDB" class="headerlink" title="访问MongoDB"></a>访问MongoDB</h2><p>在Spring Boot中，对如此受欢迎的MongoDB，同样提供了自配置功能。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>Spring Boot中可以通过在<code>pom.xml</code>中加入<code>spring-boot-starter-data-mongodb</code>引入对mongodb的访问支持依赖。它的实现依赖<code>spring-data-mongodb</code>。是的，您没有看错，又是<code>spring-data</code>的子项目，之前介绍过<code>spring-data-jpa</code>、<code>spring-data-redis</code>，对于mongodb的访问，<code>spring-data</code>也提供了强大的支持，下面就开始动手试试吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="快速开始使用Spring-data-mongodb"><a href="#快速开始使用Spring-data-mongodb" class="headerlink" title="快速开始使用Spring-data-mongodb"></a>快速开始使用Spring-data-mongodb</h4><p>若MongoDB的安装配置采用默认端口，那么在自动配置的情况下，我们不需要做任何参数配置，就能马上连接上本地的MongoDB。下面直接使用<code>spring-data-mongodb</code>来尝试对mongodb的存取操作。（记得mongod启动您的mongodb）</p><ul><li>创建要存储的User实体，包含属性：id、username、age</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public User(Long id, String username, Integer age) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现User的数据访问对象：UserRepository</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends MongoRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    User findByUsername(String username);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在单元测试中调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void setUp() &#123;</span><br><span class="line">userRepository.deleteAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 创建三个User，并验证User总数</span><br><span class="line">userRepository.save(new User(1L, &quot;didi&quot;, 30));</span><br><span class="line">userRepository.save(new User(2L, &quot;mama&quot;, 40));</span><br><span class="line">userRepository.save(new User(3L, &quot;kaka&quot;, 50));</span><br><span class="line">Assert.assertEquals(3, userRepository.findAll().size());</span><br><span class="line"></span><br><span class="line">// 删除一个User，再验证User总数</span><br><span class="line">User u = userRepository.findOne(1L);</span><br><span class="line">userRepository.delete(u);</span><br><span class="line">Assert.assertEquals(2, userRepository.findAll().size());</span><br><span class="line"></span><br><span class="line">// 删除一个User，再验证User总数</span><br><span class="line">u = userRepository.findByUsername(&quot;mama&quot;);</span><br><span class="line">userRepository.delete(u);</span><br><span class="line">Assert.assertEquals(1, userRepository.findAll().size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>通过上面的例子，我们可以轻而易举的对MongoDB进行访问，但是实战中，应用服务器与MongoDB通常不会部署于同一台设备之上，这样就无法使用自动化的本地配置来进行使用。这个时候，我们也可以方便的配置来完成支持，只需要在application.properties中加入mongodb服务端的相关配置，具体示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.uri=mongodb://name:pass@localhost:27017/test</span><br></pre></td></tr></table></figure><p><em>在尝试此配置时，记得在mongo中对test库创建具备读写权限的用户（用户名为name，密码为pass），不同版本的用户创建语句不同，注意查看文档做好准备工作</em></p><p>若使用mongodb 2.x，也可以通过如下参数配置，该方式不支持mongodb 3.x。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.host=localhost spring.data.mongodb.port=27017</span><br></pre></td></tr></table></figure><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>本文的相关例子可以查看下面仓库中的<code>chapter3-2-6</code>目录：</p><ul><li>Github：<a href="https://github.com/WuliGitH/SpringBoot-Learning-1">https://github.com/WuliGitH/SpringBoot-Learning-1</a></li></ul><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 ,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot多数据源配置与使用</title>
      <link href="/2019/03/02/4fe8d14b0209/"/>
      <url>/2019/03/02/4fe8d14b0209/</url>
      
        <content type="html"><![CDATA[<p>之前在介绍使用JdbcTemplate和Spring-data-jpa时，都使用了单数据源。在单数据源的情况下，Spring Boot的配置非常简单，只需要在<code>application.properties</code>文件中配置连接参数即可。但是往往随着业务量发展，我们通常会进行数据库拆分或是引入其他数据库，从而我们需要配置多个数据源，下面基于之前的JdbcTemplate和Spring-data-jpa例子分别介绍两种多数据源的配置方式。<span id="more"></span></p><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><p>创建一个Spring配置类，定义两个DataSource用来读取<code>application.properties</code>中的不同配置。如下例子中，主数据源配置为<code>spring.datasource.primary</code>开头的配置，第二数据源配置为<code>spring.datasource.secondary</code>开头的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;primaryDataSource&quot;)</span><br><span class="line">    @Qualifier(&quot;primaryDataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)</span><br><span class="line">    public DataSource primaryDataSource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;secondaryDataSource&quot;)</span><br><span class="line">    @Qualifier(&quot;secondaryDataSource&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    @ConfigurationProperties(prefix=&quot;spring.datasource.secondary&quot;)</span><br><span class="line">    public DataSource secondaryDataSource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的<code>application.properties</code>配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.primary.url=jdbc:mysql://localhost:3306/test1</span><br><span class="line">spring.datasource.primary.username=root</span><br><span class="line">spring.datasource.primary.password=root</span><br><span class="line">spring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.secondary.url=jdbc:mysql://localhost:3306/test2</span><br><span class="line">spring.datasource.secondary.username=root</span><br><span class="line">spring.datasource.secondary.password=root</span><br><span class="line">spring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><h3 id="JdbcTemplate支持"><a href="#JdbcTemplate支持" class="headerlink" title="JdbcTemplate支持"></a>JdbcTemplate支持</h3><p>对JdbcTemplate的支持比较简单，只需要为其注入对应的datasource即可，如下例子，在创建JdbcTemplate的时候分别注入名为<code>primaryDataSource</code>和<code>secondaryDataSource</code>的数据源来区分不同的JdbcTemplate。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean(name = &quot;primaryJdbcTemplate&quot;)</span><br><span class="line">public JdbcTemplate primaryJdbcTemplate(</span><br><span class="line">        @Qualifier(&quot;primaryDataSource&quot;) DataSource dataSource) &#123;</span><br><span class="line">    return new JdbcTemplate(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean(name = &quot;secondaryJdbcTemplate&quot;)</span><br><span class="line">public JdbcTemplate secondaryJdbcTemplate(</span><br><span class="line">        @Qualifier(&quot;secondaryDataSource&quot;) DataSource dataSource) &#123;</span><br><span class="line">    return new JdbcTemplate(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过测试用例来演示如何使用这两个针对不同数据源的JdbcTemplate。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;primaryJdbcTemplate&quot;)</span><br><span class="line">protected JdbcTemplate jdbcTemplate1;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;secondaryJdbcTemplate&quot;)</span><br><span class="line">protected JdbcTemplate jdbcTemplate2;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void setUp() &#123;</span><br><span class="line">jdbcTemplate1.update(&quot;DELETE  FROM  USER &quot;);</span><br><span class="line">jdbcTemplate2.update(&quot;DELETE  FROM  USER &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 往第一个数据源中插入两条数据</span><br><span class="line">jdbcTemplate1.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 1, &quot;aaa&quot;, 20);</span><br><span class="line">jdbcTemplate1.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 2, &quot;bbb&quot;, 30);</span><br><span class="line"></span><br><span class="line">// 往第二个数据源中插入一条数据，若插入的是第一个数据源，则会主键冲突报错</span><br><span class="line">jdbcTemplate2.update(&quot;insert into user(id,name,age) values(?, ?, ?)&quot;, 1, &quot;aaa&quot;, 20);</span><br><span class="line"></span><br><span class="line">// 查一下第一个数据源中是否有两条数据，验证插入是否成功</span><br><span class="line">Assert.assertEquals(&quot;2&quot;, jdbcTemplate1.queryForObject(&quot;select count(1) from user&quot;, String.class));</span><br><span class="line"></span><br><span class="line">// 查一下第一个数据源中是否有两条数据，验证插入是否成功</span><br><span class="line">Assert.assertEquals(&quot;1&quot;, jdbcTemplate2.queryForObject(&quot;select count(1) from user&quot;, String.class));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong></p><p>可以查看下面仓库中的<code>chapter3-2-3</code>目录：</p><ul><li>Github：<a href="https://github.com/WuliGitH/SpringBoot-Learning-1">https://github.com/WuliGitH/SpringBoot-Learning-1</a></li></ul><p><strong>如果您觉得本文不错，欢迎Star支持，您的关注是我坚持的动力！</strong></p><h3 id="Spring-data-jpa支持"><a href="#Spring-data-jpa支持" class="headerlink" title="Spring-data-jpa支持"></a>Spring-data-jpa支持</h3><p>对于数据源的配置可以沿用上例中<code>DataSourceConfig</code>的实现。</p><p>新增对第一数据源的JPA配置，注意两处注释的地方，用于指定数据源对应的<code>Entity</code>实体和<code>Repository</code>定义位置，用<code>@Primary</code>区分主数据源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@EnableJpaRepositories(</span><br><span class="line">        entityManagerFactoryRef=&quot;entityManagerFactoryPrimary&quot;,</span><br><span class="line">        transactionManagerRef=&quot;transactionManagerPrimary&quot;,</span><br><span class="line">        basePackages= &#123; &quot;com.didispace.domain.p&quot; &#125;) //设置Repository所在位置</span><br><span class="line">public class PrimaryConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired @Qualifier(&quot;primaryDataSource&quot;)</span><br><span class="line">    private DataSource primaryDataSource;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean(name = &quot;entityManagerPrimary&quot;)</span><br><span class="line">    public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return entityManagerFactoryPrimary(builder).getObject().createEntityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean(name = &quot;entityManagerFactoryPrimary&quot;)</span><br><span class="line">    public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return builder</span><br><span class="line">                .dataSource(primaryDataSource)</span><br><span class="line">                .properties(getVendorProperties(primaryDataSource))</span><br><span class="line">                .packages(&quot;com.didispace.domain.p&quot;) //设置实体类所在位置</span><br><span class="line">                .persistenceUnit(&quot;primaryPersistenceUnit&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) &#123;</span><br><span class="line">        return jpaProperties.getHibernateProperties(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean(name = &quot;transactionManagerPrimary&quot;)</span><br><span class="line">    public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增对第二数据源的JPA配置，内容与第一数据源类似，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@EnableJpaRepositories(</span><br><span class="line">        entityManagerFactoryRef=&quot;entityManagerFactorySecondary&quot;,</span><br><span class="line">        transactionManagerRef=&quot;transactionManagerSecondary&quot;,</span><br><span class="line">        basePackages= &#123; &quot;com.didispace.domain.s&quot; &#125;) //设置Repository所在位置</span><br><span class="line">public class SecondaryConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired @Qualifier(&quot;secondaryDataSource&quot;)</span><br><span class="line">    private DataSource secondaryDataSource;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;entityManagerSecondary&quot;)</span><br><span class="line">    public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return entityManagerFactorySecondary(builder).getObject().createEntityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;entityManagerFactorySecondary&quot;)</span><br><span class="line">    public LocalContainerEntityManagerFactoryBean entityManagerFactorySecondary (EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return builder</span><br><span class="line">                .dataSource(secondaryDataSource)</span><br><span class="line">                .properties(getVendorProperties(secondaryDataSource))</span><br><span class="line">                .packages(&quot;com.didispace.domain.s&quot;) //设置实体类所在位置</span><br><span class="line">                .persistenceUnit(&quot;secondaryPersistenceUnit&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) &#123;</span><br><span class="line">        return jpaProperties.getHibernateProperties(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &quot;transactionManagerSecondary&quot;)</span><br><span class="line">    PlatformTransactionManager transactionManagerSecondary(EntityManagerFactoryBuilder builder) &#123;</span><br><span class="line">        return new JpaTransactionManager(entityManagerFactorySecondary(builder).getObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了以上配置之后，主数据源的实体和数据访问对象位于：<code>com.didispace.domain.p</code>，次数据源的实体和数据访问接口位于：<code>com.didispace.domain.s</code>。</p><p>分别在这两个package下创建各自的实体和数据访问接口</p><ul><li>主数据源下，创建User实体和对应的Repository接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public User()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, Integer age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter、setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从数据源下，创建Message实体和对应的Repository接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Message &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public Message()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Message(String name, String content) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter、setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public interface MessageRepository extends JpaRepository&lt;Message, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过测试用例来验证使用这两个针对不同数据源的配置进行数据操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserRepository userRepository;</span><br><span class="line">@Autowired</span><br><span class="line">private MessageRepository messageRepository;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">userRepository.save(new User(&quot;aaa&quot;, 10));</span><br><span class="line">userRepository.save(new User(&quot;bbb&quot;, 20));</span><br><span class="line">userRepository.save(new User(&quot;ccc&quot;, 30));</span><br><span class="line">userRepository.save(new User(&quot;ddd&quot;, 40));</span><br><span class="line">userRepository.save(new User(&quot;eee&quot;, 50));</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(5, userRepository.findAll().size());</span><br><span class="line"></span><br><span class="line">messageRepository.save(new Message(&quot;o1&quot;, &quot;aaaaaaaaaa&quot;));</span><br><span class="line">messageRepository.save(new Message(&quot;o2&quot;, &quot;bbbbbbbbbb&quot;));</span><br><span class="line">messageRepository.save(new Message(&quot;o3&quot;, &quot;cccccccccc&quot;));</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(3, messageRepository.findAll().size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong></p><p>可以查看下面仓库中的<code>chapter3-2-4</code>目录：</p><ul><li>Github：<a href="https://github.com/WuliGitH/SpringBoot-Learning-1">https://github.com/WuliGitH/SpringBoot-Learning-1</a></li></ul><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 ,</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中使用Redis数据库</title>
      <link href="/2019/02/28/9d5fee73be1c/"/>
      <url>/2019/02/28/9d5fee73be1c/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot中除了对常用的关系型数据库提供了优秀的自动化支持之外，对于很多NoSQL数据库一样提供了自动化配置的支持，包括：Redis, MongoDB, Elasticsearch, Solr和Cassandra。<span id="more"></span></p><h2 id="使用Redis"><a href="#使用Redis" class="headerlink" title="使用Redis"></a>使用Redis</h2><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。</p><ul><li><a href="http://redis.io/">Redis官网</a></li><li><a href="http://www.redis.cn/">Redis中文社区</a></li></ul><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>Spring Boot提供的数据访问框架Spring Data Redis基于Jedis。可以通过引入<code>spring-boot-starter-redis</code>来配置依赖关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>按照惯例在<code>application.properties</code>中加入Redis服务端的相关配置，具体说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure><p><strong>其中spring.redis.database的配置通常使用0即可，Redis在配置的时候可以设置数据库数量，默认为16，可以理解为数据库的schema</strong></p><h4 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h4><p>通过编写测试用例，举例说明如何访问Redis。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 保存字符串</span><br><span class="line">stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段极为简单的测试案例演示了如何通过自动配置的<code>StringRedisTemplate</code>对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。如果有使用过spring-data-redis的开发者一定熟悉<code>RedisTemplate&lt;K, V&gt;</code>接口，<code>StringRedisTemplate</code>就相当于<code>RedisTemplate&lt;String, String&gt;</code>的实现。</p><p>除了String类型，实战中我们还经常会在Redis中存储对象，这时候我们就会想是否可以使用类似<code>RedisTemplate&lt;String, User&gt;</code>来初始化并进行操作。但是Spring Boot并不支持直接使用，需要我们自己实现<code>RedisSerializer&lt;T&gt;</code>接口来对传入对象进行序列化和反序列化，下面我们通过一个实例来完成对象的读写操作。</p><ul><li>创建要存储的对象：User</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -1L;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public User(String username, Integer age) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现对象的序列化接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class RedisObjectSerializer implements RedisSerializer&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private Converter&lt;Object, byte[]&gt; serializer = new SerializingConverter();</span><br><span class="line">  private Converter&lt;byte[], Object&gt; deserializer = new DeserializingConverter();</span><br><span class="line"></span><br><span class="line">  static final byte[] EMPTY_ARRAY = new byte[0];</span><br><span class="line"></span><br><span class="line">  public Object deserialize(byte[] bytes) &#123;</span><br><span class="line">    if (isEmpty(bytes)) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      return deserializer.convert(bytes);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">      throw new SerializationException(&quot;Cannot deserialize&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public byte[] serialize(Object object) &#123;</span><br><span class="line">    if (object == null) &#123;</span><br><span class="line">      return EMPTY_ARRAY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      return serializer.convert(object);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">      return EMPTY_ARRAY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private boolean isEmpty(byte[] data) &#123;</span><br><span class="line">    return (data == null || data.length == 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置针对User的RedisTemplate实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    JedisConnectionFactory jedisConnectionFactory() &#123;</span><br><span class="line">        return new JedisConnectionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, User&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, User&gt; template = new RedisTemplate&lt;String, User&gt;();</span><br><span class="line">        template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(new RedisObjectSerializer());</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完成了配置工作后，编写测试用例实验效果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String, User&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 保存对象</span><br><span class="line">User user = new User(&quot;超人&quot;, 20);</span><br><span class="line">redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line"></span><br><span class="line">user = new User(&quot;蝙蝠侠&quot;, 30);</span><br><span class="line">redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line"></span><br><span class="line">user = new User(&quot;蜘蛛侠&quot;, 40);</span><br><span class="line">redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(20, redisTemplate.opsForValue().get(&quot;超人&quot;).getAge().longValue());</span><br><span class="line">Assert.assertEquals(30, redisTemplate.opsForValue().get(&quot;蝙蝠侠&quot;).getAge().longValue());</span><br><span class="line">Assert.assertEquals(40, redisTemplate.opsForValue().get(&quot;蜘蛛侠&quot;).getAge().longValue());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然spring-data-redis中提供的数据操作远不止这些，本文仅作为在Spring Boot中使用redis时的配置参考，更多对于redis的操作使用，请参考<a href="http://docs.spring.io/spring-data/redis/docs/1.6.2.RELEASE/reference/html/">Spring-data-redis Reference</a>。</p><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot日志管理</title>
      <link href="/2019/02/27/6a6fe4369131/"/>
      <url>/2019/02/27/6a6fe4369131/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Spring Boot在所有内部日志中使用<a href="http://commons.apache.org/proper/commons-logging/">Commons Logging</a>，但是默认配置也提供了对常用日志的支持，如：<a href="http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html">Java Util Logging</a>，<a href="http://logging.apache.org/log4j/">Log4J</a>, <a href="http://logging.apache.org/log4j/">Log4J2</a>和<a href="http://logback.qos.ch/">Logback</a>。每种Logger都可以通过配置使用控制台或者文件输出日志内容。<span id="more"></span></p><h2 id="格式化日志"><a href="#格式化日志" class="headerlink" title="格式化日志"></a>格式化日志</h2><p>默认的日志输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">04</span>-<span class="number">13</span> 08:<span class="number">23</span>:<span class="number">50.120</span>  INFO <span class="number">37397</span> --- [           main] org.hibernate.Version                    : HHH000412: Hibernate Core &#123;<span class="number">4.3</span><span class="number">.11</span>.Final&#125;</span><br></pre></td></tr></table></figure><p>输出内容元素具体如下：</p><ul><li>时间日期 — 精确到毫秒</li><li>日志级别 — ERROR, WARN, INFO, DEBUG or TRACE</li><li>进程ID</li><li>分隔符 — <code>---</code> 标识实际日志的开始</li><li>线程名 — 方括号括起来（可能会截断控制台输出）</li><li>Logger名 — 通常使用源代码的类名</li><li>日志内容</li></ul><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>在Spring Boot中默认配置了<code>ERROR</code>、<code>WARN</code>和<code>INFO</code>级别的日志输出到控制台。</p><p>我们可以通过两种方式切换至<code>DEBUG</code>级别：</p><ul><li>在运行命令后加入<code>--debug</code>标志，如：<code>$ java -jar myapp.jar --debug</code></li><li>在<code>application.properties</code>中配置<code>debug=true</code>，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。</li></ul><h4 id="多彩输出"><a href="#多彩输出" class="headerlink" title="多彩输出"></a>多彩输出</h4><p>如果你的终端支持ANSI，设置彩色输出会让日志更具可读性。通过在<code>application.properties</code>中设置<code>spring.output.ansi.enabled</code>参数来支持。</p><ul><li>NEVER：禁用ANSI-colored输出（默认项）</li><li>DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（推荐项）</li><li>ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用</li></ul><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>Spring Boot默认配置只会输出到控制台，并不会记录到文件中，但是我们通常生产环境使用时都需要以文件方式记录。</p><p>若要增加文件输出，需要在<code>application.properties</code>中配置<code>logging.file</code>或<code>logging.path</code>属性。</p><ul><li>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：<code>logging.file=my.log</code></li><li>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：<code>logging.path=/var/log</code></li></ul><p><strong>日志文件会在10Mb大小的时候被截断，产生新的日志文件，默认级别为：ERROR、WARN、INFO</strong></p><h2 id="级别控制"><a href="#级别控制" class="headerlink" title="级别控制"></a>级别控制</h2><p>在Spring Boot中只需要在<code>application.properties</code>中进行配置完成日志记录的级别控制。</p><p>配置格式：<code>logging.level.*=LEVEL</code></p><ul><li><code>logging.level</code>：日志级别控制前缀，<code>*</code>为包名或Logger名</li><li><code>LEVEL</code>：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</li></ul><p>举例：</p><ul><li><code>logging.level.com.didispace=DEBUG</code>：<code>com.didispace</code>包下所有class以DEBUG级别输出</li><li><code>logging.level.root=WARN</code>：root日志以WARN级别输出</li></ul><h2 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h2><p>由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。</p><p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p><ul><li>Logback：<code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, <code>logback.groovy</code></li><li>Log4j：<code>log4j-spring.properties</code>, <code>log4j-spring.xml</code>, <code>log4j.properties</code>, <code>log4j.xml</code></li><li>Log4j2：<code>log4j2-spring.xml</code>, <code>log4j2.xml</code></li><li>JDK (Java Util Logging)：<code>logging.properties</code></li></ul><p><strong>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml）</strong></p><h2 id="自定义输出格式"><a href="#自定义输出格式" class="headerlink" title="自定义输出格式"></a>自定义输出格式</h2><p>在Spring Boot中可以通过在<code>application.properties</code>配置如下参数控制输出格式：</p><ul><li>logging.pattern.console：定义输出到控制台的样式（不支持JDK Logger）</li><li>logging.pattern.file：定义输出到文件的样式（不支持JDK Logger）</li></ul></li></ul><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中使用Spring-data-jpa让数据访问更简单、更优雅</title>
      <link href="/2019/02/26/6b15248d70c1/"/>
      <url>/2019/02/26/6b15248d70c1/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在上一篇 Spring中使用JdbcTemplate访问数据库 中介绍了一种基本的数据访问方式，结合 构建RESTful API 和 使用Thymeleaf模板引擎渲染Web视图 的内容就已经可以完成App服务端和Web站点的开发任务了。</p><p>  然而，在实际开发过程中，对数据库的操作无非就“增删改查”。就最为普遍的单表操作而言，除了表和字段不同外，语句都是类似的，开发人员需要写大量类似而枯燥的语句来完成业务逻辑。<span id="more"></span></p><p>  为了解决这些大量枯燥的数据操作语句，我们第一个想到的是使用ORM框架，比如：Hibernate。通过整合Hibernate之后，我们以操作Java实体的方式最终将数据改变映射到数据库表中。</p><p>  为了解决抽象各个Java实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板Dao来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板Dao的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆Dao的接口和实现。</p><p>  由于模板Dao的实现，使得这些具体实体的Dao层已经变的非常“薄”，有一些具体实体的Dao实现可能完全就是对模板Dao的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring-data-jpa的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。比如，下面的例子：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    User findByName(String name);</span><br><span class="line"></span><br><span class="line">    @Query(&quot;from User u where u.name=:name&quot;)</span><br><span class="line">    User findUser(@Param(&quot;name&quot;) String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们只需要通过编写一个继承自<code>JpaRepository</code>的接口就能完成数据访问，下面以一个具体实例来体验Spring-data-jpa给我们带来的强大功能。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>  由于Spring-data-jpa依赖于Hibernate。如果您对Hibernate有一定了解，下面内容可以毫不费力的看懂并上手使用Spring-data-jpa。如果您还是Hibernate新手，您可以先按如下方式入门，再建议回头学习一下Hibernate以帮助这部分的理解和进一步使用。</p><h4 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h4><p>  在<code>pom.xml</code>中添加相关依赖，加入以下内容：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>  在<code>application.properties</code>中配置：数据库连接信息（如使用嵌入式数据库则不需要）、自动创建表结构的设置，例如使用mysql的情况如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/test</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.jpa.properties.hibernate.ddl-auto=create-drop</span><br></pre></td></tr></table></figure><p>  <code>spring.jpa.properties.hibernate.ddl-auto</code>是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：</p><ul><li><code>create</code>：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</li><li><code>create-drop</code>：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。</li><li><code>update</code>：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</li><li><code>validate</code>：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</li></ul><p>  至此已经完成基础配置，如果您有在Spring下整合使用过它的话，相信你已经感受到Spring Boot的便利之处：JPA的传统配置在<code>persistence.xml</code>文件中，但是这里我们不需要。</p><h4 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h4><p>  创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了<code>spring.jpa.properties.hibernate.ddl-auto</code>，在应用启动的时候框架会自动去数据库中创建对应的表。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    // 省略构造函数</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建数据访问接口"><a href="#创建数据访问接口" class="headerlink" title="创建数据访问接口"></a>创建数据访问接口</h4><p>  下面针对User实体创建对应的<code>Repository</code>接口实现对该实体的数据访问，如下代码：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    User findByName(String name);</span><br><span class="line"></span><br><span class="line">    User findByNameAndAge(String name, Integer age);</span><br><span class="line"></span><br><span class="line">    @Query(&quot;from User u where u.name=:name&quot;)</span><br><span class="line">    User findUser(@Param(&quot;name&quot;) String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在Spring-data-jpa中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类，直接减少了我们的文件清单。</p><p>  下面对上面的<code>UserRepository</code>做一些解释，该接口继承自<code>JpaRepository</code>，通过查看<code>JpaRepository</code>接口的<a href="http://docs.spring.io/spring-data/data-jpa/docs/current/api/">API文档</a>，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。</p><p>  在我们实际开发中，<code>JpaRepository</code>接口定义的接口往往还不够或者性能不够优化，我们需要进一步实现更复杂一些的查询或操作。由于本文重点在spring boot中整合spring-data-jpa，在这里先抛砖引玉简单介绍一下spring-data-jpa中让我们兴奋的功能，后续再单独开篇讲一下spring-data-jpa中的常见使用。</p><p>  在上例中，我们可以看到下面两个函数：</p><ul><li><code>User findByName(String name)</code></li><li><code>User findByNameAndAge(String name, Integer age)</code></li></ul><p>  它们分别实现了按name查询User实体和按name和age查询User实体，可以看到我们这里没有任何类SQL语句就完成了两个条件查询方法。这就是Spring-data-jpa的一大特性：<strong>通过解析方法名创建查询</strong>。</p><p>  除了通过解析方法名来创建查询外，它也提供通过使用@Query 注解来创建查询，您只需要编写JPQL语句，并通过类似“:name”来映射@Param指定的参数，就像例子中的第三个findUser函数一样。</p><p>  <strong>Spring-data-jpa的能力远不止本文提到的这些，由于本文主要以整合介绍为主，对于Spring-data-jpa的使用只是介绍了常见的使用方式。诸如@Modifying操作、分页排序、原生SQL支持以及与Spring MVC的结合使用等等内容就不在本文中详细展开，这里先挖个坑，后续再补文章填坑，如您对这些感兴趣可以关注我博客或简书，同样欢迎大家留言交流想法。</strong></p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>  在完成了上面的数据访问接口之后，按照惯例就是编写对应的单元测试来验证编写的内容是否正确。这里就不多做介绍，主要通过数据操作和查询来反复验证操作的正确性。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@SpringApplicationConfiguration(Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建10条记录</span></span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;AAA&quot;</span>, <span class="number">10</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;BBB&quot;</span>, <span class="number">20</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;CCC&quot;</span>, <span class="number">30</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;DDD&quot;</span>, <span class="number">40</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;EEE&quot;</span>, <span class="number">50</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;FFF&quot;</span>, <span class="number">60</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;GGG&quot;</span>, <span class="number">70</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;HHH&quot;</span>, <span class="number">80</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;III&quot;</span>, <span class="number">90</span>));</span><br><span class="line">userRepository.save(<span class="keyword">new</span> User(<span class="string">&quot;JJJ&quot;</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试findAll, 查询所有记录</span></span><br><span class="line">Assert.assertEquals(<span class="number">10</span>, userRepository.findAll().size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试findByName, 查询姓名为FFF的User</span></span><br><span class="line">Assert.assertEquals(<span class="number">60</span>, userRepository.findByName(<span class="string">&quot;FFF&quot;</span>).getAge().longValue());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试findUser, 查询姓名为FFF的User</span></span><br><span class="line">Assert.assertEquals(<span class="number">60</span>, userRepository.findUser(<span class="string">&quot;FFF&quot;</span>).getAge().longValue());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试findByNameAndAge, 查询姓名为FFF并且年龄为60的User</span></span><br><span class="line">Assert.assertEquals(<span class="string">&quot;FFF&quot;</span>, userRepository.findByNameAndAge(<span class="string">&quot;FFF&quot;</span>, <span class="number">60</span>).getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试删除姓名为AAA的User</span></span><br><span class="line">userRepository.delete(userRepository.findByName(<span class="string">&quot;AAA&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试findAll, 查询所有记录, 验证上面的删除是否成功</span></span><br><span class="line">Assert.assertEquals(<span class="number">9</span>, userRepository.findAll().size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中使用JdbcTemplate访问数据库</title>
      <link href="/2019/02/25/f2f82558f344/"/>
      <url>/2019/02/25/f2f82558f344/</url>
      
        <content type="html"><![CDATA[<p>之前介绍了很多Web层的例子，包括构建RESTful API、使用Thymeleaf模板引擎渲染Web视图，但是这些内容还不足以构建一个动态的应用。通常我们做App也好，做Web应用也好，都需要内容，而内容通常存储于各种类型的数据库，服务端在接收到访问请求之后需要访问数据库获取并处理成展现给用户使用的数据形式。</p><p>本文介绍在Spring Boot基础下配置数据源和通过JdbcTemplate编写数据访问的示例。<span id="more"></span></p><h2 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h2><p>在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。</p><p>首先，为了连接数据库需要引入jdbc支持，在<code>pom.xml</code>中引入如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h4><p>嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot提供自动配置的嵌入式数据库有H2、HSQL、Derby，你不需要提供任何连接配置就能使用。</p><p>比如，我们可以在<code>pom.xml</code>中引入如下配置使用HSQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="连接生产数据源"><a href="#连接生产数据源" class="headerlink" title="连接生产数据源"></a>连接生产数据源</h4><p>以MySQL数据库为例，先引入MySQL连接的依赖包，在<code>pom.xml</code>中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>src/main/resources/application.properties</code>中配置数据源信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/test</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><h4 id="连接JNDI数据源"><a href="#连接JNDI数据源" class="headerlink" title="连接JNDI数据源"></a>连接JNDI数据源</h4><p>当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.jndi-name=java:jboss/datasources/customers</span><br></pre></td></tr></table></figure><h2 id="使用JdbcTemplate操作数据库"><a href="#使用JdbcTemplate操作数据库" class="headerlink" title="使用JdbcTemplate操作数据库"></a>使用JdbcTemplate操作数据库</h2><p>Spring的JdbcTemplate是自动配置的，你可以直接使用<code>@Autowired</code>来注入到你自己的bean中来使用。</p><p>举例：我们在创建<code>User</code>表，包含属性<code>name</code>、<code>age</code>，下面来编写数据访问对象和单元测试用例。</p><ul><li>定义包含有插入、删除、查询的抽象接口UserService</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增一个用户</span><br><span class="line">     * @param name</span><br><span class="line">     * @param age</span><br><span class="line">     */</span><br><span class="line">    void create(String name, Integer age);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据name删除一个用户高</span><br><span class="line">     * @param name</span><br><span class="line">     */</span><br><span class="line">    void deleteByName(String name);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取用户总量</span><br><span class="line">     */</span><br><span class="line">    Integer getAllUsers();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除所有用户</span><br><span class="line">     */</span><br><span class="line">    void deleteAllUsers();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过JdbcTemplate实现UserService中定义的数据访问操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void create(String name, Integer age) &#123;</span><br><span class="line">        jdbcTemplate.update(&quot;insert into USER(NAME, AGE) values(?, ?)&quot;, name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void deleteByName(String name) &#123;</span><br><span class="line">        jdbcTemplate.update(&quot;delete from USER where NAME = ?&quot;, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer getAllUsers() &#123;</span><br><span class="line">        return jdbcTemplate.queryForObject(&quot;select count(1) from USER&quot;, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void deleteAllUsers() &#123;</span><br><span class="line">        jdbcTemplate.update(&quot;delete from USER&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserService userSerivce;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void setUp() &#123;</span><br><span class="line">// 准备，清空user表</span><br><span class="line">userSerivce.deleteAllUsers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line">// 插入5个用户</span><br><span class="line">userSerivce.create(&quot;a&quot;, 1);</span><br><span class="line">userSerivce.create(&quot;b&quot;, 2);</span><br><span class="line">userSerivce.create(&quot;c&quot;, 3);</span><br><span class="line">userSerivce.create(&quot;d&quot;, 4);</span><br><span class="line">userSerivce.create(&quot;e&quot;, 5);</span><br><span class="line"></span><br><span class="line">// 查数据库，应该有5个用户</span><br><span class="line">Assert.assertEquals(5, userSerivce.getAllUsers().intValue());</span><br><span class="line"></span><br><span class="line">// 删除两个用户</span><br><span class="line">userSerivce.deleteByName(&quot;a&quot;);</span><br><span class="line">userSerivce.deleteByName(&quot;e&quot;);</span><br><span class="line"></span><br><span class="line">// 查数据库，应该有5个用户</span><br><span class="line">Assert.assertEquals(3, userSerivce.getAllUsers().intValue());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>上面介绍的JdbcTemplate只是最基本的几个操作，更多其他数据访问操作的使用请参考：JdbcTemplate API</em></p><p>通过上面这个简单的例子，我们可以看到在Spring Boot下访问数据库的配置依然秉承了框架的初衷：简单。我们只需要在pom.xml中加入数据库依赖，再到application.properties中配置连接信息，不需要像Spring应用中创建JdbcTemplate的Bean，就可以直接在自己的对象中注入使用</p><blockquote><p>文章转自 <a href="http://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中使用Swagger2构建强大的RESTful API文档</title>
      <link href="/2019/02/24/278a7a2ae6d6/"/>
      <url>/2019/02/24/278a7a2ae6d6/</url>
      
        <content type="html"><![CDATA[<ul><li><p>由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。<span id="more"></span></p><p>这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题：</p><ul><li>由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。</li><li>随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。</li></ul><p>为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示：</p><p><img src="https://img.jacian.com/20190521112908.png"></p><p>下面来具体介绍，如果在Spring Boot中使用Swagger2。首先，我们需要一个Spring Boot实现的RESTful API工程，若您没有做过这类内容，建议先阅读<br><a href="/2019/02/1550905200000/">Spring Boot构建一个较为复杂的RESTful APIs和单元测试</a>。</p><p>下面的内容我们会以<a href="https://github.com/WuliGitH/SpringBoot-Learning-1">教程样例</a>中的Chapter3-1-1进行下面的实验（Chapter3-1-5是我们的结果工程，亦可参考）。</p><h4 id="添加Swagger2依赖"><a href="#添加Swagger2依赖" class="headerlink" title="添加Swagger2依赖"></a>添加Swagger2依赖</h4><p>在<code>pom.xml</code>中加入Swagger2的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="创建Swagger2配置类"><a href="#创建Swagger2配置类" class="headerlink" title="创建Swagger2配置类"></a>创建Swagger2配置类</h4><p>在<code>Application.java</code>同级创建Swagger2的配置类<code>Swagger2</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;cn.rickyxd.web&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;Spring Boot中使用Swagger2构建RESTful APIs&quot;)</span><br><span class="line">                .description(&quot;更多Spring Boot相关文章请关注：https://img.jacian.com/&lt;br&gt;&lt;br&gt;&lt;h3&gt;Create By Ricky Liu&lt;/h3&gt;&quot;)</span><br><span class="line">                //.termsOfServiceUrl(&quot;https://img.jacian.com/&quot;)</span><br><span class="line">                //.contact(&quot;Ricky Liu&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，通过<code>@Configuration</code>注解，让Spring来加载该类配置。再通过在启动类上添加<code>@EnableSwagger2</code>注解来启用Swagger2。</p><p>再通过<code>createRestApi</code>函数创建<code>Docket</code>的Bean之后，<code>apiInfo()</code>用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。<code>select()</code>函数返回一个<code>ApiSelectorBuilder</code>实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被<code>@ApiIgnore</code>指定的请求）。</p><h4 id="添加文档内容"><a href="#添加文档内容" class="headerlink" title="添加文档内容"></a>添加文档内容</h4><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过<code>@ApiOperation</code>注解来给API增加说明、通过<code>@ApiImplicitParams</code>、<code>@ApiImplicitParam</code>注解来给参数增加说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">// 配置使以下映射都在 /users 下</span><br><span class="line">@RequestMapping(&quot;/users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建线程安全的Map</span><br><span class="line">     */</span><br><span class="line">    private static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理 &quot;/users/&quot; 的GET请求,用来获取用户列表</span><br><span class="line">     * 还可以通过 @RequestParam 从页面中传递参数进行查询条件或者分页信息的传递</span><br><span class="line">     * @return 用户列表</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)</span><br><span class="line">    @GetMapping(&quot;/&quot;)</span><br><span class="line">    public List&lt;User&gt; getUserList() &#123;</span><br><span class="line">        return new ArrayList&lt;User&gt;(users.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理 &quot;/users/&quot; 的 POST 请求 , 用来创建 User</span><br><span class="line">     *  还可以通过@RequestParam从页面中传递参数</span><br><span class="line">     * @param user 用户信息</span><br><span class="line">     * @return 创建 user 的成功与否</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    @PostMapping(&quot;/&quot;)</span><br><span class="line">    public String postUser(@RequestBody User user) &#123;</span><br><span class="line">        users.put(user.getId(), user);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息</span><br><span class="line">     *  url中的id可通过@PathVariable绑定到函数的参数中</span><br><span class="line">     * @param id 用户ID</span><br><span class="line">     * @return 用户信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public User getUser(@PathVariable Long id) &#123;</span><br><span class="line">        // 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息</span><br><span class="line">        // url中的id可通过@PathVariable绑定到函数的参数中</span><br><span class="line">        return users.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理&quot;/users/&#123;id&#125;&quot;的PUT请求，用来更新User信息</span><br><span class="line">     * @param id 用户ID</span><br><span class="line">     * @param user 更新后的用户信息</span><br><span class="line">     * @return 是否更新成功</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @PutMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String putUser(@PathVariable Long id, @RequestBody User user) &#123;</span><br><span class="line">        User u = users.get(id);</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        users.put(id, u);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理&quot;/users/&#123;id&#125;&quot;的DELETE请求，用来删除User</span><br><span class="line">     * @param id 用户ID</span><br><span class="line">     * @return 是否删除成功</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)</span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String deleteUser(@PathVariable Long id) &#123;</span><br><span class="line">        users.remove(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="https://localhost:8080/swagger-ui.html">https://localhost:8080/swagger-ui.html</a><br>。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，单击<code>Try it out</code>，如下图所示。</p><p><img src="https://img.jacian.com/20190521112947.png"></p><p>输入属性对应的值点击Execute即代表发送相应请求</p><p><img src="https://img.jacian.com/20190521113011.png"></p><h4 id="API文档访问与调试"><a href="#API文档访问与调试" class="headerlink" title="API文档访问与调试"></a>API文档访问与调试</h4><p>在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方<code>“Try it out！”</code>按钮，即可完成了一次请求调用！</p><p>此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。</p><p>相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。</p></li></ul><h4 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h4><ul><li><a href="(https://swagger.io/)https://swagger.io/">Swagger官方网站</a></li></ul><blockquote><p>文章转自 <a href="https://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot构建RESTful API与单元测试</title>
      <link href="/2019/02/23/2a422e6cbddf/"/>
      <url>/2019/02/23/2a422e6cbddf/</url>
      
        <content type="html"><![CDATA[<ul><li><code>@Controller</code>：修饰class，用来创建处理http请求的对象</li><li><code>@RestController</code>：Spring4之后加入的注解，原来在<code>@Controller</code>中返回json需要<code>@ResponseBody</code>来配合，如果直接用<code>@RestController</code>替代<code>@Controller</code>就不需要再配置<code>@ResponseBody</code>，默认返回json格式。</li><li><code>@RequestMapping</code>：配置url映射<span id="more"></span></li></ul><p>下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。</p><p><strong>RESTful API具体设计如下：</strong></p><p><img src="https://img.jacian.com/20190521113032.png"></p><p>User实体定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略setter和getter</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现对User对象的操作接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">// 配置使以下映射都在 /users 下</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建线程安全的Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, User&gt; users = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Long, User&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 &quot;/users/&quot; 的GET请求,用来获取用户列表</span></span><br><span class="line"><span class="comment">     * 还可以通过 <span class="doctag">@RequestParam</span> 从页面中传递参数进行查询条件或者分页信息的传递</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;User&gt;(users.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 &quot;/users/&quot; 的 POST 请求 , 用来创建 User</span></span><br><span class="line"><span class="comment">     *  还可以通过<span class="doctag">@RequestParam</span>从页面中传递参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建 user 的成功与否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        users.put(user.getId(), user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息</span></span><br><span class="line"><span class="comment">     *  url中的id可通过<span class="doctag">@PathVariable</span>绑定到函数的参数中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息</span></span><br><span class="line">        <span class="comment">// url中的id可通过@PathVariable绑定到函数的参数中</span></span><br><span class="line">        <span class="keyword">return</span> users.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&#123;id&#125;&quot;的PUT请求，用来更新User信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 更新后的用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否更新成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@ModelAttribute</span> User user)</span> </span>&#123;</span><br><span class="line">        User u = users.get(id);</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        users.put(id, u);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&#123;id&#125;&quot;的DELETE请求，用来删除User</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        users.remove(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@SpringApplicationConfiguration(classes = MockServletContext.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">mvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> UserController()).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserController</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 测试UserController</span></span><br><span class="line">RequestBuilder request = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、get查一下user列表，应该为空</span></span><br><span class="line">request = get(<span class="string">&quot;/users/&quot;</span>);</span><br><span class="line">mvc.perform(request)</span><br><span class="line">.andExpect(status().isOk())</span><br><span class="line">.andExpect(content().string(equalTo(<span class="string">&quot;[]&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、post提交一个user</span></span><br><span class="line">request = post(<span class="string">&quot;/users/&quot;</span>)</span><br><span class="line">.param(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">.param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试大师&quot;</span>)</span><br><span class="line">.param(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">mvc.perform(request)</span><br><span class="line">        .andExpect(content().string(equalTo(<span class="string">&quot;success&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、get获取user列表，应该有刚才插入的数据</span></span><br><span class="line">request = get(<span class="string">&quot;/users/&quot;</span>);</span><br><span class="line">mvc.perform(request)</span><br><span class="line">.andExpect(status().isOk())</span><br><span class="line">.andExpect(content().string(equalTo(<span class="string">&quot;[&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;测试大师\&quot;,\&quot;age\&quot;:20&#125;]&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、put修改id为1的user</span></span><br><span class="line">request = put(<span class="string">&quot;/users/1&quot;</span>)</span><br><span class="line">.param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;测试终极大师&quot;</span>)</span><br><span class="line">.param(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line">mvc.perform(request)</span><br><span class="line">.andExpect(content().string(equalTo(<span class="string">&quot;success&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、get一个id为1的user</span></span><br><span class="line">request = get(<span class="string">&quot;/users/1&quot;</span>);</span><br><span class="line">mvc.perform(request)</span><br><span class="line">.andExpect(content().string(equalTo(<span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;测试终极大师\&quot;,\&quot;age\&quot;:30&#125;&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、del删除id为1的user</span></span><br><span class="line">request = delete(<span class="string">&quot;/users/1&quot;</span>);</span><br><span class="line">mvc.perform(request)</span><br><span class="line">.andExpect(content().string(equalTo(<span class="string">&quot;success&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、get查一下user列表，应该为空</span></span><br><span class="line">request = get(<span class="string">&quot;/users/&quot;</span>);</span><br><span class="line">mvc.perform(request)</span><br><span class="line">.andExpect(status().isOk())</span><br><span class="line">.andExpect(content().string(equalTo(<span class="string">&quot;[]&quot;</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们通过引入web模块（没有做其他的任何配置），就可以轻松利用Spring MVC的功能，以非常简洁的代码完成了对User对象的RESTful API的创建以及单元测试的编写。其中同时介绍了Spring MVC中最为常用的几个核心注解：<code>@Controller</code>,<code>@RestController</code>,<code>RequestMapping</code>以及一些参数绑定的注解：<code>@PathVariable</code>,<code>@ModelAttribute</code>,<code>@RequestParam</code>等。</p><blockquote><p>文章转自 <a href="https://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot开发Web应用</title>
      <link href="/2019/02/22/20f0a8cbf392/"/>
      <url>/2019/02/22/20f0a8cbf392/</url>
      
        <content type="html"><![CDATA[<h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。<span id="more"></span></p><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：</p><ul><li>/static</li><li>/public</li><li>/resources</li><li>/META-INF/resources</li></ul><p>举例：我们可以在<code>src/main/resources/</code>目录下创建<code>static</code>，在该位置放置一个图片文件。启动程序后，尝试访问<code>https://localhost:8080/D.jpg</code>。如能显示图片，配置成功。</p><p><img src="https://img.jacian.com/20190521113104.png"></p><h2 id="渲染Web页面"><a href="#渲染Web页面" class="headerlink" title="渲染Web页面"></a>渲染Web页面</h2><p>在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。</p><p>Spring Boot提供了默认配置的模板引擎主要有以下几种：</p><ul><li>Thymeleaf</li><li>FreeMarker</li><li>Velocity</li><li>Groovy</li><li>Mustache</li></ul><p><strong>Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置</strong></p><p>当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：<code>src/main/resources/templates</code>。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。</p><h4 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h4><p>Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。</p><p>Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。</p><p>示例模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;thead&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;th th:text=&quot;#&#123;msgs.headers.name&#125;&quot;&gt;Name&lt;/td&gt;</span><br><span class="line">      &lt;th th:text=&quot;#&#123;msgs.headers.price&#125;&quot;&gt;Price&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/thead&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">    &lt;tr th:each=&quot;prod : $&#123;allProducts&#125;&quot;&gt;</span><br><span class="line">      &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Oranges&lt;/td&gt;</span><br><span class="line">      &lt;td th:text=&quot;$&#123;#numbers.formatDecimal(prod.price,1,2)&#125;&quot;&gt;0.99&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。</p><p>在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径<code>src/main/resources/templates</code>下编写模板文件即可完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String index(ModelMap map) &#123;</span><br><span class="line">        // 加入一个属性，用来在模板中读取</span><br><span class="line">        map.addAttribute(&quot;host&quot;, &quot;https://img.jacian.com&quot;);</span><br><span class="line">        // return模板文件的名称，对应src/main/resources/templates/index.html</span><br><span class="line">        return &quot;index&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如上页面，直接打开html页面展现Hello World，但是启动程序后，访问<code>https://localhost:8080/</code>，则是展示Controller中host的值：<code>https://img.jacian.com</code>，做到了不破坏HTML自身内容的数据逻辑分离。</p><p>更多Thymeleaf的页面语法，还请访问Thymeleaf的官方文档查询使用。</p><p><strong>Thymeleaf的默认参数配置</strong></p><p>如有需要修改默认配置的时候，只需复制下面要修改的属性到<code>application.properties</code>中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  thymeleaf:</span><br><span class="line">    cache: true</span><br><span class="line">    check-template-location: true</span><br><span class="line">    content-type: text/html</span><br><span class="line">    enabled: true</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    mode: HTML5</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    suffix: .html</span><br></pre></td></tr></table></figure><h3 id="支持JSP的配置"><a href="#支持JSP的配置" class="headerlink" title="支持JSP的配置"></a>支持JSP的配置</h3><p>Spring Boot并不建议使用，但如果一定要使用，可以参考此工程作为脚手架：<a href="https://github.com/spring-projects/spring-boot/tree/v1.3.2.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp">JSP支持</a></p><blockquote><p>文章转自 <a href="https://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot快速入门</title>
      <link href="/2019/02/21/094bdb1e5131/"/>
      <url>/2019/02/21/094bdb1e5131/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot主要优点"><a href="#SpringBoot主要优点" class="headerlink" title="SpringBoot主要优点"></a>SpringBoot主要优点</h2><ul><li>为所有Spring开发者更快的入门</li><li>开箱即用，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求<span id="more"></span></li></ul><h2 id="本文所用工具版本"><a href="#本文所用工具版本" class="headerlink" title="本文所用工具版本"></a>本文所用工具版本</h2><ul><li>Maven3.6.0</li><li>JDK 1.8</li><li>SpringBoot 1.5.19</li></ul><h2 id="使用Maven构建项目"><a href="#使用Maven构建项目" class="headerlink" title="使用Maven构建项目"></a>使用Maven构建项目</h2><ol><li><p>通过 SPRING INITIALIZR 构建项目</p><ol><li><p>访问: <code>https://start.spring.io/</code> ;</p></li><li><p>选择构建工具<code>Maven Project</code>、Spring Boot版本<code>1.5.19</code>以及一些工程基本信息，可参考下图所示 ;</p><p><img src="https://img.jacian.com/20190521113131.png" alt="SPRING INITIALIZR 构建项目"></p></li><li><p>点击 Generate Project下载项目压缩包 ;</p></li></ol></li><li><p>解压项目包 , 并用IDE 以<code>Maven</code>项目导入 , 以 <code>IDEA</code> 为例</p><ol><li><p>菜单中选择<code>File</code>–&gt;<code>New</code>–&gt;<code>Project from Existing Sources...</code></p><p><img src="https://img.jacian.com/20190521113204.png"></p></li><li><p>选择解压后的项目文件夹，点击<code>OK</code></p></li><li><p>点击<code>Import project from external model</code>并选择<code>Maven</code>，点击<code>Next</code>到底为止。</p><p><img src="https://img.jacian.com/20190521113237.png"></p></li><li><p>若你的环境有多个版本的JDK，注意到选择<code>Java SDK</code>的时候请选择<code>Java 7</code>以上的版本</p><p><img src="https://img.jacian.com/20190521113254.png"></p></li></ol></li></ol><h2 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h2><p><img src="https://img.jacian.com/20190521113313.png"></p><p>通过上面步骤完成了基础项目的创建，如上图所示，Spring Boot的基础结构共三个文件（具体路径根据用户生成项目时填写的Group所有差异）：</p><ul><li><code>src/main/java</code>下的程序入口：<code>Learning1Application</code></li><li><code>src/main/resources</code>下的配置文件：<code>application.properties</code></li><li><code>src/test/</code>下的测试入口：<code>Learning1ApplicationTests</code></li></ul><p>生成的<code>Learning1Application</code>和<code>Learning1ApplicationTests</code>类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或Web模块，程序会在加载完Spring之后结束运行。</p><h2 id="引入Web模块"><a href="#引入Web模块" class="headerlink" title="引入Web模块"></a>引入Web模块</h2><p>当前的<code>pom.xml</code>内容如下，仅引入了两个模块：</p><ul><li><code>spring-boot-starter</code>：核心模块，包括自动配置支持、日志和YAML</li><li><code>spring-boot-starter-test</code>：测试模块，包括JUnit、Hamcrest、Mockito</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入Web模块，需添加<code>spring-boot-starter-web</code>模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写HelloWorld服务"><a href="#编写HelloWorld服务" class="headerlink" title="编写HelloWorld服务"></a>编写HelloWorld服务</h2><ul><li><p>创建<code>package</code>命名为<code>cn.rickyxd.web</code>（根据实际情况修改）</p></li><li><p>创建<code>HelloWorldController</code>类，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HelloWorld!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动主程序，打开浏览器访问<code>https://localhost:8080/hello</code>，可以看到页面输出<code>Hello World</code></p></li></ul><p><img src="https://img.jacian.com/20190521113332.png"></p><h2 id="编写单元测试用例"><a href="#编写单元测试用例" class="headerlink" title="编写单元测试用例"></a>编写单元测试用例</h2><p>打开的<code>src/test/</code>下的测试入口<code>Chapter1ApplicationTests</code>类。下面编写一个简单的单元测试来模拟http请求，具体如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="comment">// 使用Spring Test组件进行单元测试 , 其中SpringRunner继承SpringJUnit4ClassRunner</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// 测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="comment">// 注入 MockMvc 实例</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Learning1ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> HelloWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/hello&quot;</span>).accept(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(equalTo(<span class="string">&quot;Hello World!&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意引入下面内容，让<code>status</code>、<code>content</code>、<code>equalTo</code>函数可用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.equalTo;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br></pre></td></tr></table></figure><blockquote><p>至此已完成目标，通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</p></blockquote><blockquote><p>文章转自 <a href="https://blog.didispace.com/">“程序猿DD”</a> 博客 .</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring加载多个properties文件报错</title>
      <link href="/2019/02/20/bca02ed12b1b/"/>
      <url>/2019/02/20/bca02ed12b1b/</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>启动web项目时保存 , 该问题出现的原因为 spring 加载 properties 文件时无法找到对应的属性值 ; </p><blockquote><p>Caused by : java.lang.IllegalArgumentException: Could not resolve placeholder ‘xxx’ in string value “${xxx}”</p></blockquote><span id="more"></span><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h2><p><img src="http://upload-images.jianshu.io/upload_images/13970177-f01066c5dc943cb8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bug"></p><p>提示我无法解析占位符 , 导入 log4j 配置文件之后 , 发现并没有加载到所对应的properties文件 ;</p><p><img src="http://upload-images.jianshu.io/upload_images/13970177-c5231718e04de51a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis-config.properties"><br>这里只是解析了 “redis-config.properties” 但是并没有加载 , 所以导致找不到对应的属性值 ;</p><h2 id="3-问题解决及原因"><a href="#3-问题解决及原因" class="headerlink" title="3. 问题解决及原因"></a>3. 问题解决及原因</h2><p>查了下资料发现 spring 容器中仅允许且最多只会扫描一个 properties 文件 , 当扫描到 properties 时 , 后边的 properties 文件会被忽略掉 ;</p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>在每个 <strong><a href="context:property-placeholder">context:property-placeholder</a></strong> 中添加 <strong>ignore-unresolvable=”true”</strong> 属性 ;<br><img src="http://upload-images.jianshu.io/upload_images/13970177-4529ceea1d5a5e7a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决方案一"></p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>将 properties 所在的文件夹名称改为一致 ;<br><img src="http://upload-images.jianshu.io/upload_images/13970177-a41fdcb3d1cf056d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决方案二"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
