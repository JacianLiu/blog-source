---
title: SpringBoot中使用Spring-data-jpa让数据访问更简单、更优雅
tags:
  - SpringBoot
categories:
  - SpringBoot
toc: true
category: SpringBoot
date: 2019-02-26 15:00:00
cover: https://img.jacian.com/Fq4RJGhYPPg3JLjFikPDYbHg4yp1
article-thumbnail: 'false'
---

* 在上一篇 Spring中使用JdbcTemplate访问数据库 中介绍了一种基本的数据访问方式，结合 构建RESTful API 和 使用Thymeleaf模板引擎渲染Web视图 的内容就已经可以完成App服务端和Web站点的开发任务了。

    然而，在实际开发过程中，对数据库的操作无非就“增删改查”。就最为普遍的单表操作而言，除了表和字段不同外，语句都是类似的，开发人员需要写大量类似而枯燥的语句来完成业务逻辑。<!-- more -->

    为了解决这些大量枯燥的数据操作语句，我们第一个想到的是使用ORM框架，比如：Hibernate。通过整合Hibernate之后，我们以操作Java实体的方式最终将数据改变映射到数据库表中。

    为了解决抽象各个Java实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板Dao来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板Dao的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆Dao的接口和实现。

    由于模板Dao的实现，使得这些具体实体的Dao层已经变的非常“薄”，有一些具体实体的Dao实现可能完全就是对模板Dao的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring-data-jpa的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。比如，下面的例子：

    ```
    public interface UserRepository extends JpaRepository<User, Long> {

        User findByName(String name);

        @Query("from User u where u.name=:name")
        User findUser(@Param("name") String name);

    }
    ```

    我们只需要通过编写一个继承自`JpaRepository`的接口就能完成数据访问，下面以一个具体实例来体验Spring-data-jpa给我们带来的强大功能。

    ## 使用示例

    由于Spring-data-jpa依赖于Hibernate。如果您对Hibernate有一定了解，下面内容可以毫不费力的看懂并上手使用Spring-data-jpa。如果您还是Hibernate新手，您可以先按如下方式入门，再建议回头学习一下Hibernate以帮助这部分的理解和进一步使用。

    #### 工程配置

    在`pom.xml`中添加相关依赖，加入以下内容：

    ```
    <dependency
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    ```

    在`application.properties`中配置：数据库连接信息（如使用嵌入式数据库则不需要）、自动创建表结构的设置，例如使用mysql的情况如下：

    ```
    spring.datasource.url=jdbc:mysql://localhost:3306/test
    spring.datasource.username=root
    spring.datasource.password=root
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

    spring.jpa.properties.hibernate.ddl-auto=create-drop
    ```

    `spring.jpa.properties.hibernate.ddl-auto`是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：

    - `create`：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
    - `create-drop`：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
    - `update`：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。
    - `validate`：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。

    至此已经完成基础配置，如果您有在Spring下整合使用过它的话，相信你已经感受到Spring Boot的便利之处：JPA的传统配置在`persistence.xml`文件中，但是这里我们不需要。

    #### 创建实体

    创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了`spring.jpa.properties.hibernate.ddl-auto`，在应用启动的时候框架会自动去数据库中创建对应的表。

    ```
    @Entity
    public class User {

        @Id
        @GeneratedValue
        private Long id;

        @Column(nullable = false)
        private String name;

        @Column(nullable = false)
        private Integer age;

        // 省略构造函数

        // 省略getter和setter

    }
    ```

    #### 创建数据访问接口

    下面针对User实体创建对应的`Repository`接口实现对该实体的数据访问，如下代码：

    ```
    public interface UserRepository extends JpaRepository<User, Long> {

        User findByName(String name);

        User findByNameAndAge(String name, Integer age);

        @Query("from User u where u.name=:name")
        User findUser(@Param("name") String name);

    }
    ```

    在Spring-data-jpa中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类，直接减少了我们的文件清单。

    下面对上面的`UserRepository`做一些解释，该接口继承自`JpaRepository`，通过查看`JpaRepository`接口的[API文档](http://docs.spring.io/spring-data/data-jpa/docs/current/api/)，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。

    在我们实际开发中，`JpaRepository`接口定义的接口往往还不够或者性能不够优化，我们需要进一步实现更复杂一些的查询或操作。由于本文重点在spring boot中整合spring-data-jpa，在这里先抛砖引玉简单介绍一下spring-data-jpa中让我们兴奋的功能，后续再单独开篇讲一下spring-data-jpa中的常见使用。

    在上例中，我们可以看到下面两个函数：

    - `User findByName(String name)`
    - `User findByNameAndAge(String name, Integer age)`

    它们分别实现了按name查询User实体和按name和age查询User实体，可以看到我们这里没有任何类SQL语句就完成了两个条件查询方法。这就是Spring-data-jpa的一大特性：**通过解析方法名创建查询**。

    除了通过解析方法名来创建查询外，它也提供通过使用@Query 注解来创建查询，您只需要编写JPQL语句，并通过类似“:name”来映射@Param指定的参数，就像例子中的第三个findUser函数一样。

    **Spring-data-jpa的能力远不止本文提到的这些，由于本文主要以整合介绍为主，对于Spring-data-jpa的使用只是介绍了常见的使用方式。诸如@Modifying操作、分页排序、原生SQL支持以及与Spring MVC的结合使用等等内容就不在本文中详细展开，这里先挖个坑，后续再补文章填坑，如您对这些感兴趣可以关注我博客或简书，同样欢迎大家留言交流想法。**

    #### 单元测试

    在完成了上面的数据访问接口之后，按照惯例就是编写对应的单元测试来验证编写的内容是否正确。这里就不多做介绍，主要通过数据操作和查询来反复验证操作的正确性。

    ```java
    @RunWith(SpringJUnit4ClassRunner.class)
    @SpringApplicationConfiguration(Application.class)
    public class ApplicationTests {

    	@Autowired
    	private UserRepository userRepository;

    	@Test
    	public void test() throws Exception {

    		// 创建10条记录
    		userRepository.save(new User("AAA", 10));
    		userRepository.save(new User("BBB", 20));
    		userRepository.save(new User("CCC", 30));
    		userRepository.save(new User("DDD", 40));
    		userRepository.save(new User("EEE", 50));
    		userRepository.save(new User("FFF", 60));
    		userRepository.save(new User("GGG", 70));
    		userRepository.save(new User("HHH", 80));
    		userRepository.save(new User("III", 90));
    		userRepository.save(new User("JJJ", 100));

    		// 测试findAll, 查询所有记录
    		Assert.assertEquals(10, userRepository.findAll().size());

    		// 测试findByName, 查询姓名为FFF的User
    		Assert.assertEquals(60, userRepository.findByName("FFF").getAge().longValue());

    		// 测试findUser, 查询姓名为FFF的User
    		Assert.assertEquals(60, userRepository.findUser("FFF").getAge().longValue());

    		// 测试findByNameAndAge, 查询姓名为FFF并且年龄为60的User
    		Assert.assertEquals("FFF", userRepository.findByNameAndAge("FFF", 60).getName());

    		// 测试删除姓名为AAA的User
    		userRepository.delete(userRepository.findByName("AAA"));

    		// 测试findAll, 查询所有记录, 验证上面的删除是否成功
    		Assert.assertEquals(9, userRepository.findAll().size());

    	}
    }
    ```



> 文章转自 ["程序猿DD"](http://blog.didispace.com/) 博客 .